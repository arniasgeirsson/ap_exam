#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[a4paper]{geometry}
\usepackage{fancyhdr}

\pagestyle{fancy}

\fancyhead[LO,LE]{Left}
\fancyhead[CO,CE]{Center}
\fancyhead[RO,RE]{Right}

\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=false,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
 % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
AP Exam 2013
\end_layout

\begin_layout Author
Arni Asgeirsson lwf986
\end_layout

\begin_layout Date
Date?
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remove or comment on all used partial functions!!!!!!!!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
- Introduction to this report (what is it about, what is the structure?,
 where are the tests?), the exam and the three questions.
\end_layout

\begin_layout Standard
- What files are being handed in?
\end_layout

\begin_layout Standard
- What is the structure of my src folder?
\end_layout

\begin_layout Standard
- That the handed in code also provides details of my implementations
\end_layout

\begin_layout Standard
- What do I feel is important to show/tell in this report?
\end_layout

\begin_layout Standard
+ How do i generally structure my assessments?
\end_layout

\begin_layout Standard
- Any general assumptions
\end_layout

\begin_layout Standard
- Any errors in the handed out code
\end_layout

\begin_layout Standard
- Where is all the code, and how much of it have I included?
\end_layout

\begin_layout Standard
- Any extra notes or comments
\end_layout

\begin_layout Section
Question 1: The 
\noun on
Salsa
\noun default
 Language
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I have chosen ReadP beacuse it also allows me to check that if the grammar
 is ambiguous.
 How exactly?
\end_layout

\begin_layout Subsection
Fixing the grammar
\end_layout

\begin_layout Standard
The given grammar is ambiguous and this must be dealt with before proceeding
 with the actual parser.
 The given grammar is as follows and we shall call this G0.
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | Command ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command ’||’ Command
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Precedence and Associativity
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
OLEKS -2: The transformation of the grammar to handle precedence does not
 strictly speaking handle precedence.
 The problem is that the | is symmetric choice, so both options are valid,
 it is not that the seond option is _not_ considered if the first matches
 as you've expected.
 This is an important aspect in compilers, but not so much in AP.
\end_layout

\begin_layout Plain Layout
OLEKS -2: On the contrary, you should've mentioned _why_ you chose to use
 <++ instead of the fully symmetric choice operator +++ in ReadP.
 The reason is that you wanted precedence.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- What is what?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is assumed that the four operators +, -, @ and || all are left-associative.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remove @ ? Wait for discu..
 answer.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- What has precedence?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I assume that + and - have the same precedence, and as the assignment text
 specifies then @ has higher precedence than ||, meaning that if we have
 the following pseudo input 
\begin_inset Quotes eld
\end_inset

cmd || cmd @ Vident
\begin_inset Quotes erd
\end_inset

 then this corresponds to the input 
\begin_inset Quotes eld
\end_inset

cmd || ( cmd @ Vident )
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
I further assume that .
 has higher precedence than + and - meaning that 
\begin_inset Quotes eld
\end_inset

r .
 x + c .
 y
\begin_inset Quotes erd
\end_inset

 is the same as 
\begin_inset Quotes eld
\end_inset

(r .
 x) + (c .
 y)
\begin_inset Quotes erd
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Needed to assume this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Do we need to fix it here in the grammar? Is that even possible? No, but
 we could help it, although the case is very small and might as well fix
 it by using the operators of ReadP ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The associativity is already in place and the precedence of +, - and .
 is also already supported by the current grammar.
 What is missing is that @ and || have the correct precedence.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
How do we then ensure this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To do so we followed a simple algorithm:
\end_layout

\begin_layout LyX-Code
A ::= A a1 A
\end_layout

\begin_layout LyX-Code
    | A a2 A
\end_layout

\begin_layout LyX-Code
    | a3 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= A a1 B
\end_layout

\begin_layout LyX-Code
    | B .
\end_layout

\begin_layout LyX-Code
B ::= B a2 C
\end_layout

\begin_layout LyX-Code
    | C .
\end_layout

\begin_layout LyX-Code
C ::= a3 .
\end_layout

\begin_layout Standard
where a1 & a2 are terminals, a3 is something 'else'
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv mere prof
\end_layout

\end_inset

 and A,B,C are non-terminals.
 Now a2 will have higher precedence than a1.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reference G0 somewhere.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following is the resulting grammar and we shall call this G1
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Left factorization
\end_layout

\begin_layout Standard
We can see that G1 contains the case of left factorization problem.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rephrase!!
\end_layout

\end_inset

 We therefore start by fixing this by doing left factorization on G1.
\end_layout

\begin_layout Standard
I have summarized how I do left factorization in the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= B a1
\end_layout

\begin_layout LyX-Code
    | B a2.
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= B A' .
\end_layout

\begin_layout LyX-Code
A'::= a1
\end_layout

\begin_layout LyX-Code
    | a2 .
\begin_inset Note Note
status open

\begin_layout Plain Layout
note that if any of the prev a1-an is nothing, then A' should also have
 epsilon e clause 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where A, As' and B are non-terminals and a1 & a2 are something else.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv det ordenligt!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting grammar is as follows and this shall be called G2.
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr Rest2 .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’x’
\end_layout

\begin_layout LyX-Code
    | ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Left recursion
\end_layout

\begin_layout Standard
When we look at G2 we can quickly see that there is a few cases of direct
 left-recursion.
 The next is I take is therefore to remove left-recursion from our current
 grammar G2, with the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= A a1
\end_layout

\begin_layout LyX-Code
    | b1 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= b1 A' .
\end_layout

\begin_layout LyX-Code
A'::= a1 A'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout Standard
where A and A' are non-terminals and a1 & b1 are 
\begin_inset Note Note
status open

\begin_layout Plain Layout
what?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When applying the procedure/algorithm on G2 we get the grammar G3 which
 is shown below:
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command2 Command' .
\end_layout

\begin_layout LyX-Code
Command' ::= ’||’ Command2 Command'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command3 Command2' .
\end_layout

\begin_layout LyX-Code
Command2' ::= ’@’ VIdent Command2'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim Expr' .
\end_layout

\begin_layout LyX-Code
Expr' ::= Rest2 Expr'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | ’.’ ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Standard
In the rest of the report G3 will be the referred grammar unless something
 else is specified.
\end_layout

\begin_layout Subsection
Assumptions on the grammar
\end_layout

\begin_layout Standard
Some of the non-terminals in the grammar are not specified in the grammar,
 and only partly described in the assignment text.
 I will therefore list my assumptions and the definitions that I use in
 my implementation.
\end_layout

\begin_layout Subsubsection
Case sensitivity
\end_layout

\begin_layout Standard
I assume that Samba is case sensitive.
 (This should be given from all definition of 
\emph on
VIdent
\emph default
 and 
\emph on
SIdent
\emph default
)
\end_layout

\begin_layout Subsubsection
integer
\end_layout

\begin_layout Standard
Is a non-negative integer number and can therefore be written with the following
 regular expression: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[0-9]^{+}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
VIdent
\end_layout

\begin_layout Standard
As the assignment text specifies then 
\emph on
VIdent
\emph default
 is a nonempty sequence of letters, digits and underscore, which starts
 with a uppercase letter and can therefore be written with the following
 regular expression:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[A-Z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
SIdent
\end_layout

\begin_layout Standard

\emph on
SIdent
\emph default
 is the same as a 
\emph on
VIdent
\emph default
 except it cannot be one of the reserved words, described below, and has
 to start with a lowercase letter, which can be described as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[a-z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
White spaces
\end_layout

\begin_layout Standard
Whitespaces are what most would expect, spaces, any tabs, newlines and unicode
 spaces
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is unicode spaces, do they belong here?
\end_layout

\end_inset

.
 As I am using ReadP I will let the the function skipSpaces
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Link to documentation
\end_layout

\end_inset

 define the exact representation of white spaces.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The reserved words, color names, 
\emph on
VIdent
\emph default
, and 
\emph on
SIdent
\emph default
 are separated by at least one white space of any kind.
 Symbolic tokens are separated by 0 or more white spaces and so are symbolic
 tokens and alpha-numeric tokens from each other.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Rephrase?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reserved Words
\end_layout

\begin_layout Standard
The reserved words are: 'viewdef', 'rectangle', 'circle', 'group' and 'view'.
\end_layout

\begin_layout Subsubsection
Color Names
\end_layout

\begin_layout Standard
The names of the color are also considered to be reserved words and are
 the following: 'blue', 'plum', 'red', 'green' and 'orange'.
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Where can I find the code? both files and appendixes?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the remaining warnings and hints.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there anything I could have done differently?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Paragraph
parseString :: String -> Either Error Program
\end_layout

\begin_layout Standard
This function is rather straight forward as it simply parses a given input
 string to a program or an error if the input string is invalid.
\end_layout

\begin_layout Paragraph
parseFile :: FilePath -> IO (Either Error Program)
\end_layout

\begin_layout Standard
This function extends the functionality of 
\family typewriter
parseString
\family default
 by reading the input string from a given file path.
\end_layout

\begin_layout Subsubsection
DataTypes
\end_layout

\begin_layout Paragraph
Error
\end_layout

\begin_layout Standard
I have defined the Error type to be of the following
\end_layout

\begin_layout LyX-Code
data Error = NoParsePossible String
\end_layout

\begin_layout LyX-Code
           | AmbiguousGrammar [(Program, String)]
\end_layout

\begin_layout LyX-Code
           | UnexpectedRemainder Program String
\end_layout

\begin_layout Standard
Here we can see that a invalid salsa program can either return that it cannot
 be parsed to anything at all, a parsed program and some remainder or multiply
 parsed programs showing that the grammar is ambiguous, or at least that
 the implementation of the grammar is.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why did I choose these three? And what do they carry?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parser functions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the use of +++ and <++
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
parse
\end_layout

\begin_layout Standard
This function takes a parser 
\emph on
p
\emph default
 of type 
\family typewriter
ReadP Program 
\family default
and a string 
\emph on
s
\emph default
 and parses 
\emph on
s
\emph default
 with 
\emph on
p
\emph default
 and and returns the parsed program or the appropriate error if the input
 did not adhere to the grammar.
\end_layout

\begin_layout Paragraph
runParser
\end_layout

\begin_layout Standard
This parser is a wrapper for the 
\family typewriter
pProgram
\family default
 parser and simply makes sure to skip spaces both before and after parsing
 a program and also makes sure that we are at the end of the input after
 parsing a program.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Doesn't this remove the need of the 'UnexpectedRemainder' error?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pProgram
\end_layout

\begin_layout Standard
Parses a program by trying to parse a list of definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs
\end_layout

\begin_layout Standard
Parses a single definition or command and then tries to parse a list of
 definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs'
\end_layout

\begin_layout Standard
Parses either a list of commands and or definitions, nothing or a symmetric
 choice of both.
\end_layout

\begin_layout Paragraph
pDefCom
\end_layout

\begin_layout Standard
Parses either a command or a definition.
\end_layout

\begin_layout Paragraph
pDefinition
\end_layout

\begin_layout Standard
Parses a definition by either parsing a view definition, rectangle, circle,
 view or a group definition.
 I decided to split 
\family typewriter
pDefinition
\family default
 into five individual parsers 
\family typewriter
hViewdef
\family default
, 
\family typewriter
hRectangle
\family default
, 
\family typewriter
hCircle
\family default
, 
\family typewriter
hView
\family default
 and 
\family typewriter
hGroup
\family default
 to make it more readable and intuitive to understand what is happening.
\end_layout

\begin_layout Paragraph
pCommand
\end_layout

\begin_layout Standard
Is the top-level parser for parsing a command by using the 
\family typewriter
pCommand'
\family default
, 
\family typewriter
pCommand2
\family default
, 
\family typewriter
pCommand2'
\family default
 and 
\family typewriter
pCommand3
\family default
 parsers.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This parses a command2 type which is either a move, bracketed or a series
 of '@' commands and then parses a command' with the previous command as
 incoming value.
\end_layout

\begin_layout Paragraph
pCommand'
\end_layout

\begin_layout Standard
Either parses a '||' command followed by another command' parsing or nothing.
\end_layout

\begin_layout Paragraph
pCommand2
\end_layout

\begin_layout Standard
First parses a command3 then parses a command2' with the command3 as incoming
 value.
\end_layout

\begin_layout Paragraph
pCommand2'
\end_layout

\begin_layout Standard
Either parses a '@' command followed by another command2' parse or nothing.
\end_layout

\begin_layout Paragraph
pCommand3
\end_layout

\begin_layout Standard
Parses either a move command or a command wrapped in a set of curly-brackets.
\end_layout

\begin_layout Paragraph
pVIdents
\end_layout

\begin_layout Standard
Parses a single vident followed by possible a list of vidents.
\end_layout

\begin_layout Paragraph
pVIdents'
\end_layout

\begin_layout Standard
Parses a list of vidents or nothing.
\end_layout

\begin_layout Paragraph
pSIdents
\end_layout

\begin_layout Standard
Parses a single sident followed by possible a list of sidents.
\end_layout

\begin_layout Paragraph
pSIdents'
\end_layout

\begin_layout Standard
Parses a list of sidents or nothing.
\end_layout

\begin_layout Paragraph
pPos
\end_layout

\begin_layout Standard
Parses a position of either the 
\family typewriter
Abs
\family default
 or 
\family typewriter
Rel
\family default
 type.
\end_layout

\begin_layout Paragraph
pExpr
\end_layout

\begin_layout Standard
Parses an expression by parsing a prim and then using that as incoming value
 to call 
\family typewriter
pExpr'
\family default
.
\end_layout

\begin_layout Paragraph
pExpr'
\end_layout

\begin_layout Standard
Starts by parsing either a plus or minus expression 
\emph on
e
\emph default
 with the incoming value and then another expr' with 
\emph on
e
\emph default
, otherwise it parses nothing by just returning the incoming value.
\end_layout

\begin_layout Paragraph
pOp
\end_layout

\begin_layout Standard
Takes an incoming expression and either parses a plus or a minus, then the
 next prim and returns this.
\end_layout

\begin_layout Paragraph
pPrim
\end_layout

\begin_layout Standard
Parses a either an integer, an expression contained within a set of parenthesis
 or either an 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rephrase!!
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pProj
\end_layout

\begin_layout Standard
This parser takes an ident as an incoming value and parses either an 'x'
 or a 'y' and then returns the appropriate Expression of type 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
.
\end_layout

\begin_layout Paragraph
pColour
\end_layout

\begin_layout Standard
Parses one of the defined colours.
\end_layout

\begin_layout Paragraph
pVIdent
\end_layout

\begin_layout Standard
Simply parses a vident and skips all white spaces both before and after
 the word.
\end_layout

\begin_layout Paragraph
pSIdent
\end_layout

\begin_layout Standard
Parses a sident and as same as the above also skips all white spaces both
 before and after the word.
 If the parsed word is one of the reserved words or one of the colour names
 then it fails, otherwise it returns the parsed word.
\end_layout

\begin_layout Paragraph
pInteger
\end_layout

\begin_layout Standard
Parses an integer and skips all white spaces both before and after the integer.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note on the use of read?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
bracks
\end_layout

\begin_layout Standard
Takes in two a characters 
\emph on
a
\emph default
 and 
\emph on
b
\emph default
 and a parser 
\emph on
p
\emph default
, and parses the 
\emph on
a
\emph default
 and 
\emph on
b
\emph default
 around the parsing of 
\emph on
p
\emph default
 with the use of 
\family typewriter
charT
\family default
 and returns the result from 
\emph on
p
\emph default
.
\end_layout

\begin_layout Paragraph
stringT
\end_layout

\begin_layout Standard
Parses a given string 
\emph on
s
\emph default
 and skips white spaces around 
\emph on
s.
\end_layout

\begin_layout Paragraph
charT
\end_layout

\begin_layout Standard
Parses a given character 
\emph on
a
\emph default
 and skips white spaces around 
\emph on
a.
\end_layout

\begin_layout Subsection
Tests?
\end_layout

\begin_layout Section
Question 2: Interpreting 
\noun on
Salsa
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Any assumptions
\end_layout

\begin_layout Standard
- How the coordinate system is defined, see page 8 - top.
\end_layout

\begin_layout Standard
- The position of the different shapes, i.e.
 their anchor points/pivot points.
\end_layout

\begin_layout Standard
- 
\begin_inset Quotes eld
\end_inset

All of these can be checked statically prior to executing the Salsa program,
 hence you don’t have to worry about proper error handling in this question.
 If you encounter an error, you should halt the interpreter by calling the
 built-in Haskell function error.
 Writing the static check, as a separate pass over the abstract syntax tree,
 is not part of the exam.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Specify what should happen with 
\begin_inset Quotes eld
\end_inset

b -> (0,0) @ A @ B
\begin_inset Quotes erd
\end_inset

: I was unable to deduce from the assignment text what exactly should happen
 in the case of ..
 I assume that ..
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the remaining warnings and hints.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Monad(s)
\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Subsubsection
Implementation functions
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Subsubsection
Graphics engine functions?
\end_layout

\begin_layout Subsection
Tests?
\end_layout

\begin_layout Section
Question 3: Atomic Transaction Server in Erlang
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Any assumptions
\end_layout

\begin_layout Standard
- Define 'atomic transaction'
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the remaining warnings and hints.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Server API / Interface functions
\end_layout

\begin_layout Subsubsection
Implementation functions
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Subsubsection
Something about the states + state functions?
\end_layout

\begin_layout Subsubsection
The answer to the problem stated at page 13 - top.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix A Tests
\end_layout

\begin_layout Subsection
Question 1 Testing
\end_layout

\begin_layout Standard
Testing of the parser implemented in the file 
\emph on
SalsaParser.hs
\emph default
 is done through the module 
\family typewriter
Test_Parser
\family default
 implemented in the file 
\emph on
Test_Parser.hs
\emph default
.
 I decided to only test my implementation through the interface of the 
\family typewriter
SalsaParser
\family default
 module.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why ? And why not also the individual parser.
 -> They are very simple..
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Test_Parser.hs
\end_layout

\begin_layout Standard
This test file implements the module 
\family typewriter
Test_Parser
\family default
 which exports the function 
\family typewriter
runAllTests
\family default
 which, as its name implies, runs all the implemented tests.
 This test file uses both QuickCheck and HUnit.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Move to somewhere else ? In introduction?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The test file is divided into three parts; a QuickCheck part, testing the
 parser with a valid input string, a HUnit part testing parsing of invalid
 input strings and that the correct precedence and associativity is maintained
 and a the third part testing that the parsing of files works as intended.
\end_layout

\begin_layout Paragraph
Part 1
\end_layout

\begin_layout Standard
The QuickCheck part defines a set of lists containing definitions of the
 different components of the Salsa grammar, not to be confused with the
 Salsa definitions described in the grammar.
 These are used when picking a random element to generate, when generating
 the different components.
 The generated test cases tend to get rather big and slow down the test
 I have therefore added a few more cases of 
\begin_inset Quotes eld
\end_inset

move
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

const
\begin_inset Quotes erd
\end_inset

 respectively to the lists commands and exprList to easily add a greater
 chance that the generated data won't grow to large.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Bla bla, describing the newtype TestProgram and the property prop_p_Program..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Limit the code explanation and focus more on the what the test tests for
 and the assessment that raises from it?
\end_layout

\begin_layout Plain Layout
Evt.
 move the code explanation into the file itself and refer to it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
As already mentioned then the test checks for that any
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Of course not all possible input values but a random subset of the possible
 input each time the test is run.
\end_layout

\end_inset

 valid input string is parsed to the correct abstract syntax tree.
 When generator a test case then nothing is predefined, all values are random
 generated by QuickCheck Gen monad so everything is tested, although each
 value is restricted to be a valid value, and every command and expr is
 within parenthesis meaning that this test does not test for precedence
 or associativity of the operators.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use verbose and comment on the generated data, is it good enough?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Conclusion:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far the tests keeps succeeding every time I run it.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
So what then?
\end_layout

\end_inset

 I assume that it works for any valid input string, this means for vidents,
 sidents, white spaces but not precedence and associativity.
\end_layout

\begin_layout Paragraph
Part 2
\end_layout

\begin_layout Standard
This part defines a lot of HUnit tests.
 These are divided into two categories: eleven precedence cases and forty-one
 error cases.
\end_layout

\begin_layout Standard
As these are unit tests I will only test a small subset of input area in
 the individual tests, but based on these tests I assume that it also works
 for the whole area
\begin_inset Note Note
status open

\begin_layout Plain Layout
rephrase?
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Precedence
\end_layout

\begin_layout Standard
The first five precedence test cases shows that the operators '@', '||','+'
 and '-' are all left associative.
\end_layout

\begin_layout Standard
The next two show that '@' has higher precedence than '||'.
\end_layout

\begin_layout Standard
Test eight and nine show that '+' and '-' has the same precedence and therefore
 it is the order that matters, even though the end result will be the same
 as + and - in themselves are commutative.
\end_layout

\begin_layout Standard
The last two shows that '.' has higher precedence than both '+' and '-'.
\end_layout

\begin_layout Subparagraph
Error
\end_layout

\begin_layout Standard
The first test shows that an empty string cannot be parsed to anything and
 is therefore not a valid input string.
\end_layout

\begin_layout Standard
The next five tests that a sident cannot be used where a vident is expected.
\end_layout

\begin_layout Standard
Test case seven to eleven shows that a vident cannot be used in place of
 a sident.
\end_layout

\begin_layout Standard
The next four tests shows some of the invalid characters that cannot be
 used in a Salsa program.
\end_layout

\begin_layout Standard
The next two test cases tests that numbers cannot be used as vidents or
 sidents.
\end_layout

\begin_layout Standard
The following two tests shows that letters cannot be used in place of numbers.
\end_layout

\begin_layout Standard
Test case twenty to twenty-two show that not any parenthesis or brackets
 can be used when surrounding a command, group or point.
\end_layout

\begin_layout Standard
The next three test cases shows some of the unsupported operators that does
 not work for the Salsa language.
\end_layout

\begin_layout Standard
The next four tests shows that a reserved word nor a colour can be used
 in place of a sident.
\end_layout

\begin_layout Standard
The thirtieth test case shows that a colour must be one of the specified
 colour names.
\end_layout

\begin_layout Standard
Test next four test cases shows that with lacking white spaces you either
 get an error or an unexpected program.
\end_layout

\begin_layout Standard
Test number 35 shows that when defining a group the given list must be non-empty.
\end_layout

\begin_layout Standard
Test case number 36 to 38 show that the Salsa language is case-sensitive.
\end_layout

\begin_layout Standard
The next two test cases show that negative integers are not supported by
 the grammar.
\end_layout

\begin_layout Standard
The last test show that the above restriction can be bypassed by simply
 creating a expression that subtracts a number from a smaller number, which
 would produce a negative integer when executed.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

All these tests return the expected result and I therefore assume that precedenc
e and associativity works as intended and adheres to the grammar, furthermore
 that the parser returns expected error with a given invalid input string.
\end_layout

\begin_layout Paragraph
Part 3
\end_layout

\begin_layout Standard
This third part contains a set of five unit tests for testing the 
\family typewriter
parseFile
\family default
 function and that it works as intended, it works as intended when parsing
 the content of the file with 
\family typewriter
parseString
\family default
 yields the same result as parsing the file with 
\family typewriter
parseFile
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test shows that an empty file is parsed as expected.
\end_layout

\begin_layout Standard
The second and the third test shows that valid Salsa files are also parsed
 as expected.
\end_layout

\begin_layout Standard
The fourth test shows that a invalid Salsa file is parsed as expected.
\end_layout

\begin_layout Standard
The fifth test case show that when parsing a file that does not exist then
 it returns the expected IO exception.
 Note that if the file do exist for some reason then this test will acts
 as a test on the content instead.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Based on these few simple tests that returned the expected values, I assume
 that function 
\family typewriter
parseFile
\family default
 works as intended.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Furthermore based on the tests described above and that they all return
 the expected results, I assume that my grammar and my implementation of
 the 
\family typewriter
SalsaParser
\family default
 module works as intended.
\end_layout

\begin_layout Subsection
Question 2 Testing
\end_layout

\begin_layout Subsection
Question 3 Testing
\end_layout

\begin_layout Section
Appendix B Code
\end_layout

\end_body
\end_document
