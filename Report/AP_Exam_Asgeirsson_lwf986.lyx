#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{fancyhdr}

\pagestyle{fancy}

\fancyhead[LO,LE]{Report}
\fancyhead[CO,CE]{Arni Asgeirsson}
\fancyhead[RO,RE]{AP Exam 2013}

\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=false,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
 % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
AP Exam 2013
\end_layout

\begin_layout Author
Arni Asgeirsson lwf986
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remove or comment on all used partial functions!!!!!!!!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Introduction to this report (what is it about, what is the structure?,
 where are the tests?), the exam and the three questions.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following is a report documenting my implementations of a Salsa parser,
 Sala interpreter written in Haskell and a multi process atomic transaction
 server written in Erlang, and all relevant thoughts, concerns and a discussion
 of interesting problems that arose while completing the work.
\end_layout

\begin_layout Standard
I believe that the greatest focus should be on these thoughts, concerns
 and discussions as they play a big part in the general assessment of arguments
 for my code, therefore these will also have great focus in this report.
 A note to the reader is that I tend to have many thoughts, concerns and
 discussions with my self, and my have a tendency to write more that others,
 although it is 
\emph on
usually
\emph default
 of high quality.
 I have noticed the very high page number, although don't fret as much of
 it is section headers and stuff like that stealing pages.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
- What files are being handed in?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I am handing in a total of 13 files and these are: 
\emph on
src/at_server/at_server.erl
\emph default
, 
\emph on
src/at_server/at_extapi.erl
\emph default
, 
\emph on
src/test_at_server.erl
\emph default
, 
\emph on
src/salsa/SalsaParser.hs
\emph default
, 
\emph on
src/salsa/SalsaInterp.hs
\emph default
, 
\emph on
src/salsa/Test_Parser.hs
\emph default
, 
\emph on
src/salsa/Test_Interp.hs
\emph default
, 
\emph on
src/salsa/Gpx.hs
\emph default
, 
\emph on
src/salsa/SalsaAst.hs
\emph default
, 
\emph on
src/salsa/test_files/multi.salsa
\emph default
, 
\emph on
src/salsa/test_files/simple.salsa
\emph default
, 
\emph on
src/salsa/test_files/empty.salsa
\emph default
, 
\emph on
src/salsa/test_files/invalid.salsa
\emph default
.
\end_layout

\begin_layout Standard
Note that I have not altered the 
\emph on
Gpx.hs
\emph default
 file nor the 
\emph on
SalsaAst.hs
\emph default
 file, these are merely added for convention.
\end_layout

\begin_layout Standard
All the files are also included to this report and can be viewed in 
\series bold
Appendix E
\series default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
I have decided to let all my tests be described in 
\series bold
Appendix A
\series default
 and therefore separated from the rest of the report and individual assessments.
 When describing my tests I also make my final assessments on the individual
 parts.
 I use both 
\emph on
QuickCheck
\emph default
 for Haskell, 
\emph on
HUnit
\emph default
 and regular unit tests when testing.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
+ How do i generally structure my assessments?
\end_layout

\begin_layout Plain Layout
- Any general assumptions
\end_layout

\begin_layout Plain Layout
- Any errors in the handed out code
\end_layout

\begin_layout Plain Layout
- Where is all the code, and how much of it have I included?
\end_layout

\begin_layout Plain Layout
- Any extra notes or comments
\end_layout

\begin_layout Plain Layout
- What flags I have used when compiling my code.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I have used the -Wall flag when compiling my Haskell code.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Note that I am aware that the function 
\family typewriter
read
\family default

\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Link to documentation
\end_layout

\end_inset


\end_layout

\end_inset

 is a partial function, although I have been taught through the Advanced
 Programming course that this one is OK to use.
\end_layout

\begin_layout Section
Question 1: The 
\noun on
Salsa
\noun default
 Language
\end_layout

\begin_layout Standard
The following describes my implementation of a Salsa parser in Haskell.
\end_layout

\begin_layout Standard
I have chosen to use ReadP as it allows me to check wether my grammar is
 ambiguous.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 How exactly?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Fixing the grammar
\end_layout

\begin_layout Standard
The given grammar is ambiguous and this must be dealt with before proceeding
 with the actual implementation.
 The given grammar is shown in 
\series bold
Appendix B
\series default
 and we shall call this G0.
\end_layout

\begin_layout Subsubsection
Precedence and Associativity
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
OLEKS -2: The transformation of the grammar to handle precedence does not
 strictly speaking handle precedence.
 The problem is that the | is symmetric choice, so both options are valid,
 it is not that the seond option is _not_ considered if the first matches
 as you've expected.
 This is an important aspect in compilers, but not so much in AP.
\end_layout

\begin_layout Plain Layout
OLEKS -2: On the contrary, you should've mentioned _why_ you chose to use
 <++ instead of the fully symmetric choice operator +++ in ReadP.
 The reason is that you wanted precedence.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is assumed that the four operators +, -, @ and || all are left-associative.
\end_layout

\begin_layout Standard
I assume that + and - have the same precedence, and as the assignment text
 specifies then @ has higher precedence than ||, meaning that if we have
 the following pseudo input 
\begin_inset Quotes eld
\end_inset

cmd || cmd @ Vident
\begin_inset Quotes erd
\end_inset

 then this corresponds to the input 
\begin_inset Quotes eld
\end_inset

cmd || ( cmd @ Vident )
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
I further assume that .
 has higher precedence than + and - meaning that 
\begin_inset Quotes eld
\end_inset

r .
 x + c .
 y
\begin_inset Quotes erd
\end_inset

 is the same as 
\begin_inset Quotes eld
\end_inset

(r .
 x) + (c .
 y)
\begin_inset Quotes erd
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Needed to assume this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The associativity is already in place and the precedence of +, - and .
 are also already supported by the current grammar.
 What is missing is that @ and || have the correct precedence.
 We can ensure this by changing the grammar with the following algorithm
 and perform it on the non-terminal Command from G0.
 We might need to use the bias choice <++ operator instead of the fully
 symmetric +++ operator some places, but if needed we will come to that.
\end_layout

\begin_layout LyX-Code
A ::= A a1 A
\end_layout

\begin_layout LyX-Code
    | A a2 A
\end_layout

\begin_layout LyX-Code
    | a3 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= A a1 B
\end_layout

\begin_layout LyX-Code
    | B .
\end_layout

\begin_layout LyX-Code
B ::= B a2 C
\end_layout

\begin_layout LyX-Code
    | C .
\end_layout

\begin_layout LyX-Code
C ::= a3 .
\end_layout

\begin_layout Standard
where a1 & a2 are terminals, a3 is something 'else'
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv mere prof
\end_layout

\end_inset

 and A,B,C are non-terminals.
 Now a2 will have higher precedence than a1.
\end_layout

\begin_layout Standard
The resulting grammar is shown in 
\series bold
Appendix B
\series default
 and we shall name it G1.
\end_layout

\begin_layout Subsubsection
Left factorization
\end_layout

\begin_layout Standard
We can see that G1 contains the case of left factorization.
 We therefore fix this by doing left factorization on G1.
\end_layout

\begin_layout Standard
I have summarized how I do left factorization in the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= B a1
\end_layout

\begin_layout LyX-Code
    | B a2.
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= B A' .
\end_layout

\begin_layout LyX-Code
A'::= a1
\end_layout

\begin_layout LyX-Code
    | a2 .
\begin_inset Note Note
status open

\begin_layout Plain Layout
note that if any of the prev a1-an is nothing, then A' should also have
 epsilon e clause 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where A and A' are non-terminals and B, a1 & a2 could be anything.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv det ordenligt!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting grammar shall be called G2, and is shown in 
\series bold
Appendix B
\series default
.
\end_layout

\begin_layout Subsubsection
Left recursion
\end_layout

\begin_layout Standard
When we look at G2 we can quickly see that there is a few cases of direct
 left-recursion.
 Therefore the next step is for me to remove left-recursion from our current
 grammar G2, with the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= A a1
\end_layout

\begin_layout LyX-Code
    | b1 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= b1 A' .
\end_layout

\begin_layout LyX-Code
A'::= a1 A'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout Standard
where A and A' are non-terminals and a1 & b1 can be anything
\begin_inset Note Note
status open

\begin_layout Plain Layout
what?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When applying the algorithm on G2 we get the grammar G3 which is shown in
 
\series bold
Appendix B
\series default
.
\end_layout

\begin_layout Standard
In the rest of the report, G3 will be the referred grammar unless something
 else is specified.
\end_layout

\begin_layout Subsection
My assumptions on the grammar
\end_layout

\begin_layout Standard
All my assumptions for the grammar can be viewed Appendix D.
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there anything I could have done differently?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code for the Salsa parser can be found in the file 
\emph on
SalsaParser.hs
\emph default
 which implements the module 
\emph on
SalsaParser
\emph default
 and exports the two function 
\family typewriter
parseString
\family default
 and 
\family typewriter
parseFile
\family default
, and the 
\family typewriter
Error
\family default
 data structure.
 The accompanied test file is called 
\emph on
Test_Parser.hs
\emph default
 and is described in 
\series bold
Appendix A
\series default
.
\end_layout

\begin_layout Standard
Note that I am aware that 
\emph on
HLint
\emph default
 spits out a hint of 
\begin_inset Quotes eld
\end_inset

Reduce duplication
\begin_inset Quotes erd
\end_inset

 although I believe that fixing the hint would negatively affect the readability
 of my code.
\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Paragraph
parseString :: String -> Either Error Program
\end_layout

\begin_layout Standard
This function is rather straight forward as it simply parses a given input
 string to a 
\family typewriter
Program
\family default
 or an 
\family typewriter
Error
\family default
 if the input string is invalid.
\end_layout

\begin_layout Paragraph
parseFile :: FilePath -> IO (Either Error Program)
\end_layout

\begin_layout Standard
This function extends the functionality of 
\family typewriter
parseString
\family default
 by reading the input string from a given file path.
\end_layout

\begin_layout Subsubsection
DataTypes
\end_layout

\begin_layout Paragraph
Error
\end_layout

\begin_layout Standard
I have defined the Error type to be of what is shown in Figure 1.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout LyX-Code
data Error = NoParsePossible String
\end_layout

\begin_layout LyX-Code
           | AmbiguousGrammar [(Program, String)]
\end_layout

\begin_layout LyX-Code
           | UnexpectedRemainder Program String
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
My Error date type.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we can see that a invalid salsa program can either return that it cannot
 be parsed to anything at all, a parsed program and some remainder or multiply
 parsed programs showing that the grammar is ambiguous, or at least that
 the implementation of the grammar is.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why did I choose these three? And what do they carry?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parser functions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the use of +++ and <++
\end_layout

\end_inset


\end_layout

\begin_layout Standard
These functions are generally not that interesting as they follow the grammar
 very strict, the following will therefore not be a very in-depth explanation,
 as there is not much depth to talk about.
\end_layout

\begin_layout Paragraph
parse :: ReadP Program -> String -> Either Error Program
\end_layout

\begin_layout Standard
This function takes a parser 
\family typewriter
p
\family default
 of type 
\family typewriter
ReadP Program 
\family default
and a string 
\family typewriter
s
\family default
 and parses 
\family typewriter
s
\family default
 with 
\family typewriter
p
\family default
 and and returns the parsed program or the appropriate error if the input
 did not adhere to the grammar.
\end_layout

\begin_layout Paragraph
runParser :: ReadP Program
\end_layout

\begin_layout Standard
This parser is a wrapper for the 
\family typewriter
pProgram
\family default
 parser and simply makes sure to skip spaces both before and after parsing
 a 
\family typewriter
Program
\family default
 and also makes sure that we are at the end of the input after parsing a
 program.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Doesn't this remove the need of the 'UnexpectedRemainder' error?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pProgram :: ReadP Program
\end_layout

\begin_layout Standard
Parses a 
\family typewriter
Program
\family default
 by trying to parse a list of definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs :: ReadP [DefCom]
\end_layout

\begin_layout Standard
Parses a single definition or command and then tries to parse a list of
 definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs' :: ReadP [DefCom]
\end_layout

\begin_layout Standard
Parses either a list of commands and or definitions, nothing or a symmetric
 choice of both.
\end_layout

\begin_layout Paragraph
pDefCom :: ReadP DefCom
\end_layout

\begin_layout Standard
Parses either a command or a definition.
\end_layout

\begin_layout Paragraph
pDefinition :: ReadP Definition
\end_layout

\begin_layout Standard
Parses a definition by either parsing a view definition, rectangle, circle,
 view or a group definition.
 I decided to split 
\family typewriter
pDefinition
\family default
 into five individual parsers 
\family typewriter
hViewdef
\family default
, 
\family typewriter
hRectangle
\family default
, 
\family typewriter
hCircle
\family default
, 
\family typewriter
hView
\family default
 and 
\family typewriter
hGroup
\family default
 to make it more readable and intuitive to understand what is happening.
\end_layout

\begin_layout Paragraph
pCommand :: ReadP Command
\end_layout

\begin_layout Standard
Is the top-level parser for parsing a command by using the 
\family typewriter
pCommand'
\family default
, 
\family typewriter
pCommand2
\family default
, 
\family typewriter
pCommand2'
\family default
 and 
\family typewriter
pCommand3
\family default
 parsers.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This parses a command2 type which is either a move, bracketed or a series
 of '@' commands and then parses a command' with the previous command as
 incoming value.
\end_layout

\begin_layout Paragraph
pCommand' :: Command -> ReadP Command
\end_layout

\begin_layout Standard
Either parses a '||' command followed by another command' parsing or nothing.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Here the parser does not use the symmetric choice operator '+++' but instead
 takes a left-biased choice meaning that if it can parse a par command,
 then it won't branch out and also try to let this parser parse nothing.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pCommand2 :: ReadP Command
\end_layout

\begin_layout Standard
First parses a command3 then parses a command2' with the command3 as incoming
 value.
\end_layout

\begin_layout Paragraph
pCommand2' :: Command -> ReadP Command
\end_layout

\begin_layout Standard
Either parses a '@' command followed by another command2' parse or nothing.
\begin_inset Note Note
status open

\begin_layout Plain Layout
 Here the symmetric choice is also voided
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pCommand3 :: ReadP Command
\end_layout

\begin_layout Standard
Parses either a move command or a command wrapped in a set of curly-brackets.
\end_layout

\begin_layout Paragraph
pVIdents :: ReadP [Ident]
\end_layout

\begin_layout Standard
Parses a single vident followed by possible a list of vidents.
\end_layout

\begin_layout Paragraph
pVIdents' :: ReadP [Ident]
\end_layout

\begin_layout Standard
Parses a list of vidents or nothing.
\end_layout

\begin_layout Paragraph
pSIdents :: ReadP [Ident]
\end_layout

\begin_layout Standard
Parses a single sident followed by possible a list of sidents.
\end_layout

\begin_layout Paragraph
pSIdents' :: ReadP [Ident]
\end_layout

\begin_layout Standard
Parses a list of sidents or nothing.
\end_layout

\begin_layout Paragraph
pPos :: ReadP Pos
\end_layout

\begin_layout Standard
Parses a position of either the 
\family typewriter
Abs
\family default
 or 
\family typewriter
Rel
\family default
 type.
\end_layout

\begin_layout Paragraph
pExpr :: ReadP Expr
\end_layout

\begin_layout Standard
Parses an expression by parsing a prim and then using that as incoming value
 to call 
\family typewriter
pExpr'
\family default
.
\end_layout

\begin_layout Paragraph
pExpr' :: Expr -> ReadP Expr
\end_layout

\begin_layout Standard
Starts by parsing either a plus or minus expression 
\family typewriter
e
\family default
 with the incoming value and then another expr' with 
\family typewriter
e
\family default
, otherwise it parses nothing by just returning the incoming value.
\end_layout

\begin_layout Paragraph
pOp :: Expr -> ReadP Expr
\end_layout

\begin_layout Standard
Takes an incoming expression and either parses a plus or a minus, then the
 associated prim and returns either a plus or minus expression.
\end_layout

\begin_layout Paragraph
pPrim :: ReadP Expr
\end_layout

\begin_layout Standard
Parses either an integer, an expression contained within a set of parenthesis
 or either an 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
 expression.
\end_layout

\begin_layout Paragraph
pProj :: Ident -> ReadP Expr
\end_layout

\begin_layout Standard
This parser takes an ident as an incoming value and parses either an 'x'
 or a 'y' and then returns the appropriate Expression of type 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
.
\end_layout

\begin_layout Paragraph
pColour :: ReadP Colour
\end_layout

\begin_layout Standard
Parses one of the defined colours.
\end_layout

\begin_layout Paragraph
pVIdent :: ReadP Ident
\end_layout

\begin_layout Standard
Simply parses a vident and skips all white spaces both before and after
 the word.
\end_layout

\begin_layout Paragraph
pSIdent :: ReadP Ident
\end_layout

\begin_layout Standard
Parses a sident and, as same as 
\family typewriter
pVIdent
\family default
, also skips all white spaces both before and after the word.
 If the parsed word is one of the reserved words or one of the colour names
 then it fails, otherwise it returns the parsed word.
\end_layout

\begin_layout Paragraph
pInteger :: ReadP Integer
\end_layout

\begin_layout Standard
Parses an integer and skips all white spaces both before and after the integer.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note on the use of read?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
bracks :: Char -> ReadP b -> Char -> ReadP b
\end_layout

\begin_layout Standard
Takes in two characters 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 and a parser 
\family typewriter
p
\family default
, and parses the 
\family typewriter
a
\family default
 and 
\family typewriter
b
\family default
 around the parsing of 
\family typewriter
p
\family default
 with the use of 
\family typewriter
charT
\family default
 and returns the result from 
\family typewriter
p
\family default
.
\end_layout

\begin_layout Paragraph
stringT :: String -> ReadP ()
\end_layout

\begin_layout Standard
Parses a given string 
\family typewriter
s
\family default
 and skips white spaces around 
\family typewriter
s
\family default
\emph on
.
\end_layout

\begin_layout Paragraph
charT :: Char -> ReadP ()
\end_layout

\begin_layout Standard
Parses a given character 
\family typewriter
c
\family default
 and skips white spaces around 
\family typewriter
c
\family default
\emph on
.
\end_layout

\begin_layout Section
Question 2: Interpreting 
\noun on
Salsa
\end_layout

\begin_layout Standard
In this section I will try and implement a Salsa interpreter in Haskell
 with the use of two monads.
 First I want to list the assumptions that I have taken while working on
 the implementation, followed by a description of my code.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
My assumptions
\end_layout

\begin_layout Itemize
As the assignment text specifies then I assume that the given input 
\family typewriter
Program
\family default
 is a valid 
\family typewriter
Program
\family default
 in that sense that it will not cause any compile errors.
 Allowing me to use the Haskell function 
\family typewriter
error
\family default
 to throw an error if an invalid 
\family typewriter
Program
\family default
 should be used in the interpreter.
\end_layout

\begin_layout Itemize
I was unsure of what a nested 
\family typewriter
At
\family default
 command should be interpreted to.
 I decided that an inner 
\family typewriter
At
\family default
 does not consider an outer and visa versa meaning that a nested 
\family typewriter
At
\family default
 command will only be visible for the innermost 
\family typewriter
At
\family default
 command.
 Consider the case 
\begin_inset Quotes eld
\end_inset

b -> (0,0) @ A @ B
\begin_inset Quotes erd
\end_inset

, here first B will be set as the active view, then A and then the move
 is performed while A is active and this no effect on B.
\end_layout

\begin_layout Itemize
I assume that when defining a group the same name cannot appear twice in
 the list.
\end_layout

\begin_layout Itemize
I assume that you cannot have group names inside a the list of views in
 a group definition.
\end_layout

\begin_layout Itemize
I assume that no two names can be used to define two things.
\end_layout

\begin_layout Itemize
I assume that the first 
\family typewriter
DefCom
\family default
 will always be a view definition, as it does not make sense to perform
 any operations on a non-existing view.
\end_layout

\begin_layout Itemize
A shape can only be moved around within a view it has been defined, i.e.
 a shape that has not been defined within a view A can never appear in A.
\end_layout

\begin_layout Itemize
The list of frames goest from left to right, i.e.
 the first keyframe is the first element of the list and the last keyframe
 is the last element.
\end_layout

\begin_layout Itemize
I assume that a shape is allowed to move outside of the bounds of a view
 that it has been define in.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- How the coordinate system is defined, see page 8 - top.
\end_layout

\begin_layout Plain Layout
- The position of the different shapes, i.e.
 their anchor points/pivot points.
\end_layout

\begin_layout Plain Layout
frame starts empty
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
My implementation of the Salsa interpreter can be found in the file 
\emph on
SalsaInterp.hs
\emph default
 which defines and implements the module 
\emph on
SalsaInterp
\emph default
.
 It exports the type 
\family typewriter
Position
\family default
 and the two functions 
\family typewriter
interpolate
\family default
 and 
\family typewriter
runProg
\family default
.
 The associated test file is 
\emph on
Test_Interp.hs
\emph default
 and is further described in 
\series bold
Appendix A
\series default
.
\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Paragraph
interpolate :: Integer -> Position -> Position -> [Position]
\end_layout

\begin_layout Standard
This function takes an 
\family typewriter
Integer
\family default
 
\family typewriter
n
\family default
, a start 
\family typewriter
Position
\family default
 
\family typewriter
p1
\family default
 and an end 
\family typewriter
Position
\family default
 
\family typewriter
p2
\family default
 and interpolates between the two positions.
 In other words the function calculates the distribution of points in a
 straight line from 
\family typewriter
p1
\family default
 to 
\family typewriter
p2
\family default
, including 
\family typewriter
p2
\family default
 and excluding 
\family typewriter
p1
\family default
, where the number of calculated points are equal to 
\family typewriter
n
\family default
, where their is an equal distance from any point to the neighbor point.
\end_layout

\begin_layout Standard
The function assumes that 
\family typewriter
n
\family default
 is non-negative.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
It is implemented by considering a straight line between 
\family typewriter
p1
\family default
 and 
\family typewriter
p2
\family default
 and then 'slice' it up in n equal sizes and then returning each 'slice'
 point and including the end point, or excluding the start point if you
 will.
 I have avoided using floating point values, and the chaos they apparently
 brought with them, to consider the length of each slice to be from 
\begin_inset Formula $0-100$
\end_inset

 instead of 
\begin_inset Formula $0.0-1.0$
\end_inset

, which does lose me some precession, but I gain a lot more readable code
 and as we have to return integers anyway, the loss is very slim.
\end_layout

\begin_layout Paragraph
runProg :: Integer -> Program -> Animation
\end_layout

\begin_layout Standard
This function initiates and runs an interpretation of a giving Program p
 with a given frame rate n, and returns the produced Animation.
 It initiates a 
\family typewriter
Salsa
\family default
 monad with an empty context and then interprets each 
\family typewriter
DefCom
\family default
 in the given 
\family typewriter
Program
\family default
.
\end_layout

\begin_layout Subsubsection
Context
\end_layout

\begin_layout Standard
As one can see in Figure 2 I have decided to let the context be a two part
 thing, where the first part represents the read-only environment, which
 is read-only for the 
\family typewriter
SalsaCommand
\family default
 monad and the second part is the read-write state.
\end_layout

\begin_layout Standard
I have named the first part 
\family typewriter
ConEnvironment
\family default
 which is a type alias for a tuple of three elements: an 
\family typewriter
Environment
\family default
 for binding idents to definitions, a list of the active views and an integer
 representing the given frame rate.
\end_layout

\begin_layout Standard
The second part is named 
\family typewriter
State
\family default
 and is a mapping from an identifier 
\family typewriter
Ident
\family default
 to a list of views and positions, describing the current location of each
 shape in each view they have been defined in.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
data Context = Context ConEnvironment State
\end_layout

\begin_layout LyX-Code
type ConEnvironment = (Environment, [Ident], Integer)
\end_layout

\begin_layout LyX-Code
type Environment = M.Map Ident Definition
\end_layout

\begin_layout LyX-Code
type State = M.Map Ident [(Ident,Position)]
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
My implementation of the 
\family typewriter
Context
\family default
 data type.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
I have also implemented a few functions to work on a 
\family typewriter
Context
\family default
 and 
\family typewriter
Animation
\family default
.
 These are described in 
\series bold
Appendix D
\series default
.
\end_layout

\begin_layout Subsubsection
The Monads
\end_layout

\begin_layout Standard
I have created two monads that when used together does the interpretation
 of a given 
\family typewriter
Program
\family default
.
\end_layout

\begin_layout Standard
The first one is named 
\family typewriter
SalsaCommand
\family default
 and its type declaration can be seen in Figure 3.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
newtype SalsaCommand a = SalsaCommand {runSC :: Context -> (a,State)}
\begin_inset Caption

\begin_layout Plain Layout
My definition of the 
\family typewriter
SalsaCommand
\family default
 monad.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As one might notice then it takes a 
\family typewriter
Context
\family default
 and returns some value 
\family typewriter
a
\family default
 and a 
\family typewriter
State
\family default
, disallowing the monad to manipulate with the given 
\family typewriter
Context
\family default

\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 as it cannot return a complete new 
\family typewriter
Context
\family default
 only the second part of one
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Am I sure of this???!?!?!
\end_layout

\end_inset

.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The second one is the 
\family typewriter
Salsa
\family default
 monad which has the declaration that can be seen in Figure 4.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
data Salsa a = Salsa ((Context,Animation) -> (a,(Context,Animation)))
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
My declaration of the 
\family typewriter
Salsa
\family default
 monad.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is a state monad that carries around a 
\family typewriter
Context
\family default
 and the 
\family typewriter
Animation
\family default
 that is being built.
 I decided to let the 
\family typewriter
Salsa
\family default
 monad carry these two around to easily manipulate with the two and return
 the completed 
\family typewriter
Animation
\family default
 once done.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The actual Monad instantiating of the two types shown above can be seen
 in 
\series bold
Appendix E
\series default
.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

My overall strategy for using the two monads is to let 
\family typewriter
Salsa
\family default
 be the top dog and the interface to the actual interpretation, it self
 interprets all definitions and builds up the context environment (part
 1) and it then uses the 
\family typewriter
SalsaCommand
\family default
 monad to interpret the commands.
 After the 
\family typewriter
Salsa
\family default
 monad has let a 
\family typewriter
SalsaCommand
\family default
 monad interpret a command and return the next 
\family typewriter
State
\family default
 of the 
\family typewriter
Context
\family default
, the 
\family typewriter
Salsa
\family default
 monad compares the previous 
\family typewriter
State
\family default
 with the new returned 
\family typewriter
State
\family default
 and generates all the needed draw instructions by interpolation between
 the two 
\family typewriter
State
\family default
s for each shape in each view where it has moved.
\end_layout

\begin_layout Standard

\family typewriter
Salsa
\family default
 then updates the global 
\family typewriter
Context
\family default
 to contain the new 
\family typewriter
State
\family default
 returned from the 
\family typewriter
SalsaCommand
\family default
.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The following is a short description of a set of functions to update the
 monads.
\end_layout

\begin_layout Paragraph
askCmd :: SalsaCommand Context
\end_layout

\begin_layout Standard
This function simply fetches the 
\family typewriter
Context
\family default
 inside a 
\family typewriter
SalsaCommand
\family default
 monad.
\end_layout

\begin_layout Paragraph
updateState :: (Context -> State) -> SalsaCommand ()
\end_layout

\begin_layout Standard

\family typewriter
updateState
\family default
 takes a function 
\family typewriter
f
\family default
 that performs some operation on a 
\family typewriter
Context
\family default
 and returns a 
\family typewriter
State
\family default
 and performs 
\family typewriter
f
\family default
 on the 
\family typewriter
Context
\family default
 within 
\family typewriter
SalsaCommand
\family default
 to alter the eventual returned 
\family typewriter
State
\family default
.
\end_layout

\begin_layout Paragraph
askCont :: Salsa Context
\end_layout

\begin_layout Standard
Does the same as 
\family typewriter
askCmd
\family default
, except now we fetch the 
\family typewriter
Context
\family default
 inside a 
\family typewriter
Salsa
\family default
 monad instead.
\end_layout

\begin_layout Paragraph
runSalsa :: Context -> Salsa a -> (a,(Context,Animation))
\end_layout

\begin_layout Standard
As the name implied this function takes some initial 
\family typewriter
Context
\family default
, a 
\family typewriter
Salsa
\family default
 monad and runs the monad, i.e.
 starts it.
\end_layout

\begin_layout Paragraph
updateContext :: (Context -> Context) -> Salsa ()
\end_layout

\begin_layout Standard
This function takes a function 
\family typewriter
f
\family default
 that takes a 
\family typewriter
Context
\family default
 and returns a 
\family typewriter
Context
\family default
, and applies this function 
\family typewriter
f
\family default
 to the inner 
\family typewriter
Context
\family default
 of a 
\family typewriter
Salsa
\family default
 monad.
\end_layout

\begin_layout Paragraph
updateAnimation :: (Animation -> Animation) -> Salsa ()
\end_layout

\begin_layout Standard

\family typewriter
updateAnimation
\family default
 takes a function 
\family typewriter
f
\family default
, that performs some operations on an 
\family typewriter
Animation
\family default
 and returns another 
\family typewriter
Animation
\family default
, and applies 
\family typewriter
f
\family default
 to the 
\family typewriter
Animation
\family default
 part of the state of a 
\family typewriter
Salsa
\family default
 monad.
\end_layout

\begin_layout Subsubsection
Interpret functions
\end_layout

\begin_layout Paragraph
command :: Command -> SalsaCommand ()
\end_layout

\begin_layout Standard
The 
\family typewriter
command
\family default
 function interprets a 
\family typewriter
Command
\family default
 
\family typewriter
cmd
\family default
 within a 
\family typewriter
SalsaCommand
\family default
 monad.
\end_layout

\begin_layout Standard
If 
\family typewriter
cmd
\family default
 is a 
\family typewriter
Move
\family default
 command then for each given shape id 
\family typewriter
sid
\family default
 we must for each view that 
\family typewriter
sid
\family default
 is located in, check if any of these are one of the currently active views,
 and if so we must update our position accordingly to the 
\family typewriter
Move
\family default
 command.
\end_layout

\begin_layout Standard
If is an 
\family typewriter
At
\family default
 command then we must update the active views to be of some temporary value,
 then execute the given command and then revert the active views to their
 previous self.
 But, as the 
\family typewriter
SalsaCommand
\family default
 cannot change the 
\family typewriter
ConEnvironment
\family default
 part, then we cannot update the currently active views, what we can do
 instead is to alter the 
\family typewriter
State
\family default
 value of the 
\family typewriter
Context
\family default
.
\end_layout

\begin_layout Standard
My trick is to use the 
\family typewriter
setTmpActiveViews
\family default
 helper function to go through the 
\family typewriter
State
\family default
 and look at each view in each binding and if the view is one of the temporary
 active views then I map it to one of the actual active views, and remember
 this mapping.
 This is done through the entire 
\family typewriter
State
\family default
, followed by now mapping all the actives views that are distinct from the
 set of temporary views to some random value that I know no one can have,
 namely something with an underscore as the first letter, of course these
 mappings are also remembered.
\end_layout

\begin_layout Standard
Now I can run the given command with the updated 
\family typewriter
State
\family default
, and when it returns I use my mappings from before to swap back, and then
 I have not changed the 
\family typewriter
Context
\family default
 and was still able to update the list of active views.
 Although this sounds very time consuming and I bet it is, a more reasonable
 way would merely to update the first part of the Context, and then run
 the command, but as I cannot see how this can be done without change the
 type of the monad, this is not an option.
\end_layout

\begin_layout Standard
The 
\family typewriter
Par
\family default
 command is a really easy one as it simply just executes the two commands.
\end_layout

\begin_layout Paragraph
defCom :: DefCom -> Salsa ()
\end_layout

\begin_layout Standard
This interpret function either interprets a 
\family typewriter
Definition
\family default
 or a 
\family typewriter
Command
\family default
, if it is a definition then nothing further needs to be done beside interpretin
g it, but if it wants to interpret a 
\family typewriter
Command
\family default
 then a 
\family typewriter
SalsaCommand
\family default
 is used with the current 
\family typewriter
Context
\family default
 of the running 
\family typewriter
Salsa
\family default
 monad, when the monad returns then we must compare the 
\family typewriter
State
\family default
 returned from the 
\family typewriter
SalsaCommand
\family default
 with our own and generate a set of instructions to go from the previous
 state to the next.
 These instructions must be added to the current frame and then as we went
 from one keyframe to the next, we must also ensure this by beginning a
 new frame.
\end_layout

\begin_layout Paragraph
definition :: Definition -> Salsa ()
\end_layout

\begin_layout Standard
This function interprets a given 
\family typewriter
Definition
\family default
.
 If it is a view definition then we evaluate the given size expressions,
 add the definition to the environment, update it to be the list of active
 views, and add the view to the list of defined views in the 
\family typewriter
Animation
\family default
.
\end_layout

\begin_layout Standard
If the definition is a simple 
\family typewriter
View
\family default
 defeinition meaning that it is not the same as above, but a statement to
 change the set of active views, then we do so by retrieving the list that
 corresponds to the given id and update the 
\family typewriter
Context
\family default
.
\end_layout

\begin_layout Standard
If it is a group definition then we add the binding to our environment and
 set the given list of view names to be the list of active views.
\end_layout

\begin_layout Standard
If we get a shape definition then we evaluate the provided values, add it
 to our environment, draw the shape in the current keyframe and in all current
 views.
 Furthermore we update our 
\family typewriter
State
\family default
 value to contain the new shape in the current active views.
\end_layout

\begin_layout Subsubsection
Interpret helper functions
\end_layout

\begin_layout Paragraph
evalNextPoint :: Pos -> Position -> SalsaCommand Position
\end_layout

\begin_layout Standard
This function simply takes a Pos and a Position pos and evaluates Pos and
 returns either a absolut position or a reletive one acording to Pos.
\end_layout

\begin_layout Paragraph
setTmpActiveViews :: State -> [Ident] -> [Ident] -> SalsaCommand (State,[((Ident
,Ident),Ident)])
\end_layout

\begin_layout Standard
As already mentioned then this function takes some 
\family typewriter
State
\family default
, a list of active views and a list of temporary views then it maps all
 occurrences of the temporary views in the 
\family typewriter
State
\family default
 with one of the active views, and then follows by mapping all occurrences
 of the active views that are distinct from the list of temporary list with
 a somewhat random value prefixed with an underscore, then it returns the
 new state and the list of all the mappings.
\end_layout

\begin_layout Paragraph
revertActiveViews :: State -> [((Ident,Ident),Ident)] -> SalsaCommand State
\end_layout

\begin_layout Standard
This function takes some 
\family typewriter
State
\family default
 
\family typewriter
s
\family default
 and a list of mappings and reverts those mappings on 
\family typewriter
s
\family default
 and returns this in the monad SalsaCommand.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
But how..
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
setNextPosition :: Eq t => [t] -> Pos -> (t, Position) -> SalsaCommand (t,
 Position)
\end_layout

\begin_layout Standard
This function takes a list of views 
\family typewriter
w
\family default
, a point and a tuple with a view 
\family typewriter
v
\family default
 and a position.
 If 
\family typewriter
v
\family default
 is in the list of views 
\family typewriter
w
\family default
, then the position must be updated in the tuple to be the result of the
 point and the position evaluated into one 
\family typewriter
Position
\family default
.
 If not then the same tuple that came in is also returned.
\end_layout

\begin_layout Paragraph
getLowestPosition :: Position -> (ViewName,Position) -> Position
\end_layout

\begin_layout Standard
Returns the lowest x-coordinate and the lowest y-coordinate to be found
 between the two given Positions.
\end_layout

\begin_layout Paragraph
compareStates :: State -> State -> Salsa [GpxInstr] 
\end_layout

\begin_layout Standard
This function compares two 
\family typewriter
State
\family default
s and generates draw instructions for each shape 
\family typewriter
s
\family default
 and for each view 
\family typewriter
s
\family default
 has been moved in.
\end_layout

\begin_layout Paragraph
generateInstructions :: Definition -> Integer -> [(ViewName, Position)]
 -> [(ViewName, Position)] -> Salsa [Frame]
\end_layout

\begin_layout Standard
This function is a helper to the compareStates function and generates a
 list of instructions for the given Definition, frame rate, list of old
 positions and list of new positions.
\end_layout

\begin_layout Paragraph
positionToInstr :: Definition -> ViewName -> Position -> Salsa GpxInstr
\end_layout

\begin_layout Standard
This functions creates a single draw instruction with for the specific shape,
 view and position.
\end_layout

\begin_layout Paragraph
evalExpr :: Monad m => Expr -> m Context -> m Integer
\end_layout

\begin_layout Standard
This function takes an 
\family typewriter
Expr
\family default
 
\family typewriter
e
\family default
 to be evaluated and something that can provide us with some context to
 use when evaluating 
\family typewriter
Xproj
\family default
 and 
\family typewriter
Yproj
\family default
 as these require that we look in the State of the 
\family typewriter
Context
\family default
 to determine what is the lowest either 
\family typewriter
x
\family default
 or 
\family typewriter
y
\family default
 value of a given shape.
 I have made the function generic by letting the 'ask' function be a parameter
 so that both the 
\family typewriter
Salsa
\family default
 and the 
\family typewriter
SalsaCommand
\family default
 monad can use the function.
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
lookupKey :: Ord a => a -> M.Map a b -> b
\end_layout

\begin_layout Standard
This function simply performs a lookup in a given tree with the key 
\family typewriter
a
\family default
 and returns the mapped value, if no mapping was found then an error is
 raised.
\end_layout

\begin_layout Paragraph
removeDouble :: [a] -> [a] -> [a]
\end_layout

\begin_layout Standard
This function takes a list 
\family typewriter
x
\family default
 and a list 
\family typewriter
y
\family default
 and returns the list 
\family typewriter
z
\family default
, where 
\family typewriter
z
\family default
 is the list that is left of 
\family typewriter
x
\family default
 when all elements that both exist in 
\family typewriter
x
\family default
 and 
\family typewriter
y
\family default
 has been pulled out of 
\family typewriter
x
\family default
.
\end_layout

\begin_layout Paragraph
evalColour :: Colour -> ColourName
\end_layout

\begin_layout Standard

\family typewriter
evalColour
\family default
 merely returns the respected string representation for a Colour type.
\end_layout

\begin_layout Paragraph
getLast :: [a] -> ([a],[a])
\end_layout

\begin_layout Standard
getLast takes in a list and returns a tuple where the first element is the
 whole input list expect for the last element and the second element of
 the tuple is the last element of the list wrapped in a list.
\end_layout

\begin_layout Section
Question 3: Atomic Transaction Server in Erlang
\end_layout

\begin_layout Standard
In this section I will implement an atomic transactions server using Erlang.
\end_layout

\begin_layout Standard
I decided to use OTP for implementing my atomic transaction server, as this
 allows me to save a lot of time building up the server from the ground
 up, and provides me and the reader with a standardized interface and behavior.
 I chose 
\emph on
gen_server
\emph default
 over the other OTP like 
\emph on
gen_fsm
\emph default
 because our server is not a finite state machine but instead a server taking
 handling a lot of requests, where 
\emph on
gen_server
\emph default
 fits this task the best.
 This also explains all the 'comments' in the file.
\end_layout

\begin_layout Subsection
My assumptions
\end_layout

\begin_layout Itemize
I always assume that the given process id, of an atomic transaction server,
 to all the interface function is indeed an atomic transaction server.
 I do no error handling nor check on this input.
\end_layout

\begin_layout Itemize
I make no assumptions on the given input State.
\end_layout

\begin_layout Itemize
I assume that no one tries to tamper with the server nor the transactions
 by guessing their process ids and sending them unwanted messages.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
COM One could force the transactions to only receive/listen to messages
 sent from the master.
 But really needed? Out of scope?
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
General structure of the server
\end_layout

\begin_layout Standard
Before proceeding to my actual implementation I want try and describe the
 overall structure of my atomic transaction server (ATS) and its managed
 transactions and requests, and some of the problems that arose.
\end_layout

\begin_layout Subsubsection
Who talks to who?
\end_layout

\begin_layout Standard
When a new ATS has been started it is started in a new process and no transactio
ns can be started nor do any live at startup.
 When a client wants to start a transaction the API function 
\family typewriter
begin_t/1
\family default
 is called and this makes the ATS spawn a new transaction, which is in fact
 an ATS process in its self but 'loops' with another state data and expects
 different requests, but referred to as a 'transaction' or 'transactions'.
 All communication to a transaction is done through the ATS in which they
 were begun.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
I have added the pid of their master in their state data so that they will
 only listen to messages sent from their own ATS master.
\end_layout

\end_inset

 All communication is done synchronously between the ATS and its transactions,
 except for the 
\family typewriter
update_t/3
\family default
 call and when a timeout occurs while trying to stop a transaction, then
 a asynchronous stop message is sent instead.
\end_layout

\begin_layout Standard
Each transaction could also just have been a tuple containing the unique
 reference, their current state and some status and not a whole process
 and the ATS would then simply just maintain a list of these, although this
 would disallow the opportunity to do any parallel work on the transactions
 which we can now with 
\family typewriter
update_t/3
\family default
, without doing some silly workaround.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Show image?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The state data
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is that?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The ATS loops with its current state, which is provided and updated by the
 client, and a pool of transactions.
 These can be idle transactions, ready to be initiated as new transactions,
 or ongoing transactions.
\end_layout

\begin_layout Standard
A transaction also loops with its current state and a status.
 This status allows the ATS to know whether the transaction is aborted,
 ready or idle.
\end_layout

\begin_layout Subsubsection
The status of each transaction and the management
\end_layout

\begin_layout Standard
As mentioned above a transaction can have one of the three status; aborted,
 ready or idle.
 aborted means that the transaction has been aborted and any further use
 while in this status should return aborted.
 ready is when the transaction has been begun but not aborted yet.
 idle means that the transaction is not used for anything right now and
 can be initiated by the ATS to act as a fresh transaction.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Although to avoid a lot of time spent communicating and waiting for responds
 from non-existing processes, then the ATS maintains it self a list of each
 transactions, by keeping their status, process id and the associated unique
 reference.
 Where it is the unique reference that acts as the key into this list allowing
 the ATS to respond quickly with 
\family typewriter
aborted
\family default
 if the process does not exist, is idle or already aborted.
 Of course this lookup operation would always take 
\begin_inset Formula $O(n)$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 is the length of the list, but the alternative would be to ask the transactions
 each time to know what their status is, and they might be busy with some
 expensive update function, and the alternative would also include the same
 lookup operation on a list of the same length, unless the ATS does not
 keep track of its transactions and therefore might risk waiting for responds
 from a process that might never respond.
\end_layout

\begin_layout Standard
There is one time the ATS needs to ask a transaction before knowing, and
 this is when a transaction failed to update its state through a 
\family typewriter
update_t/3
\family default
 call as this is done asynchronously the server won't know until it asks
 the transaction.
 Although once the server knows then it updates its own list, so it won't
 have to ask again.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
why not let the transaction send a message to the ATS once it knows himself?
 -> well the message queue could be unordered and what if the messages arrives
 to late, and mixes up the system? (Could that happen?)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
There is also a slight overhead of maintaining this list but I believe that
 it overcomes the mentioned alternative.
 An improvement could be to use another data structure to that has faster
 lookup and replace operations, as these are the most frequent operations
 used
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
what could be better? why didnt i do it? -> out of scope
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
When looking through my code one might notice that this status is not always
 maintained by the transaction it self, and this is because the ATS gives
 more credit to its own list, and will only ask transaction if it is listed
 to be in status ready.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

To sum um the above by answering to the posed problem:
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

Also, processes waiting for answers from aborted transactions must be answered
 with aborted as quickly as possible.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
My solution is to let the ATS maintain a list of the statuses of each ongoing
 transaction to respond quickly by avoiding the hassle to communicate with
 a process before answering.
\end_layout

\begin_layout Subsubsection
The pool
\end_layout

\begin_layout Standard
I like to use pools.
 There, I said it.
 But I am aware that this might not be the intention in this assignment,
 and that is why I have defined a 'global-variable' in top of the 
\emph on
at_server
\emph default
 module 
\family typewriter
MIN_POOL
\family default
 that if set to true the ATS will not keep any idle transactions in its
 pool, with other words, not maintain a pool.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The fact that I map the unique reference to a process id in the ATS allows
 me to maintain a pool of idle workers as when an idle transaction gets
 initiated as a new transaction, a new reference is merely created and the
 old association is updated to the new reference which is also returned
 to the client.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
An argument for maintaining a pool could be that if the server is heavy
 used and many transactions are begun and many are aborted due to either
 failing functions or commits.
 A lot of overhead will come from destroying and creating all these processes
 and in such a case it could be better them let them 'stick-around' instead
 of being destroyed for a quicker revival.
 Of course if the server is barely used, a pool would be of not much use,
 and might even cause extra overhead to keep these processes alive.
 An alternative could be to add these idle processes in a sleeping-queue
 avoiding that they wastes any cpu cycles being idle.
\end_layout

\begin_layout Standard
As a side-note then I tried to do some small upscaled tests to test if any
 difference were to be found using the pool or not, but no noticeable difference
 were to be discovered.
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
The following is a description of my implementation of the 
\emph on
at_server
\emph default
 module and the 
\emph on
at_extapi
\emph default
 module, which can be found in the files 
\emph on
at_server.erl
\emph default
 and 
\emph on
at_extapi.erl
\emph default
, and most of the interesting problems that arose.
 As already mentioned then I have defined the 
\family typewriter
MIN_POOL
\family default
 value at the top of the 
\emph on
at_server
\emph default
 module, I have also defined a 
\family typewriter
TIME_OUT
\family default
 value to allow for quick change of the accepted timeout value sent with
 each synchronous call to the processes, this is mostly used to go from
 the general default value 
\emph on
5000ms
\emph default
 to 
\family typewriter
infinity
\family default
.
 I advice you to not set the 
\family typewriter
TIME_OUT
\family default
 value to 
\family typewriter
infinity
\family default
 when running my tests as some of them will cause the server in a dead_lock
 state where the server is waiting for a transaction and visa versa.
\end_layout

\begin_layout Subsubsection
The Server API / Interface functions
\end_layout

\begin_layout Standard
Note that to try and avoid letting the processes crash I have tried to catch
 the timeout error around each synchronous call too and within the server,
 although if the 
\family typewriter
TIME_OUT
\family default
 value is set to something very low my 
\family typewriter
tryUpdate/0
\family default
 test will fail with 
\family typewriter
timeout
\family default
 in its fourth test case, which I for some reason cannot explain nor fix.
\end_layout

\begin_layout Paragraph
start(State)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use start or start_link?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function creates a new atomic transaction server and returns the message
 
\family typewriter
{ok,Pid}
\family default
 where 
\family typewriter
Pid
\family default
 is the process id of the newly created ATS.
\end_layout

\begin_layout Standard
Several ATSs can be started using 
\family typewriter
start/1
\family default
 and run independently.
\end_layout

\begin_layout Standard
Note that I don't make any assumptions on the given 
\family typewriter
State
\family default
 value, as this should be allowed to be anything and is defined through
 the functions that act upon it.
\end_layout

\begin_layout Paragraph
stop(AT)
\end_layout

\begin_layout Standard

\family typewriter
stop/1
\family default
 makes a synchronous call to the ATS with the given process id 
\family typewriter
AT
\family default
, and orders it to shutdown and return the current state.
 
\family typewriter
stop/1
\family default
 will not return until all processes handled by the ATS, including it self,
 has been shutdown, allowing the caller to be certain that when 
\family typewriter
stop/1
\family default
 returns everything is cleaned up.
 Instead of making the call asynchronous and forcing the caller to be in
 doubt and ultimately the need to wait some random amount of time before
 the processes are shutdown, or have some unexpected behavior.
\end_layout

\begin_layout Standard
Of course with the exception that the 
\family typewriter
TIME_OUT
\family default
 value has been set to something other than 
\family typewriter
infinity
\family default
.
\end_layout

\begin_layout Paragraph
doquery(AT, Fun)
\end_layout

\begin_layout Standard
This function performs the given function 
\family typewriter
Fun
\family default
 on the current state of the ATS with pid 
\family typewriter
AT
\family default
 and returns the result in the form 
\family typewriter
{ok, Result}
\family default
.
 
\end_layout

\begin_layout Standard
If 
\family typewriter
Fun
\family default
 fails 
\family typewriter
error
\family default
 is returned.
 
\family typewriter
doquery/2
\family default
 does not update the state of the server in any way.
\end_layout

\begin_layout Paragraph
begin_t(AT)
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The call to the server to create a new transaction is sent synchronous meaning
 that the transaction is ready to use.
 But is it really that? Is start/3 really sure that it is started when it
 returns?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here a new transaction is initialized and retrieves a copy of the current
 state of the given ATS, and a unique reference to the transaction is returned.
 Updates and queries can then be performed on the new transaction, although
 it belongs to the ATS that it was created within, and can therefore not
 be used to update the state of some other ATS.
\end_layout

\begin_layout Standard
For the unique reference, 
\family typewriter
make_ref()
\family default
 is used as it guarantees that approximately the first 
\begin_inset Formula $2^{82}$
\end_inset

 created references are unique
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.erlang.org/doc/man/erlang.html#make_ref-0
\end_layout

\end_inset

.
 One could just return the process id of the transaction, but this makes
 it easier for the user to send unwanted messages to the transactions, stop
 it or in any other way mess it up.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Is the process id as unique as make_ref/0 ?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
query_t(AT, Ref, Fun)
\end_layout

\begin_layout Standard

\family typewriter
query/3
\family default
 makes a synchronous call to the specified ATS which in turn makes a synchronous
 call to the specified transaction 
\family typewriter
Ref
\family default
 and performs 
\family typewriter
Fun
\family default
 on the state of 
\family typewriter
Ref
\family default
 and returns the result to the original caller.
 The state of 
\family typewriter
Ref
\family default
 is not updated in any way.
\end_layout

\begin_layout Standard
If the function fails in any way, then the transaction is aborted and 
\family typewriter
aborted
\family default
 is returned to the caller.
\end_layout

\begin_layout Standard
If 
\family typewriter
Ref
\family default
 is an already aborted transaction or non-existing transaction then 
\family typewriter
aborted
\family default
 is returned.
\end_layout

\begin_layout Paragraph
update_t(AT, Ref, Fun)
\end_layout

\begin_layout Standard

\family typewriter
update_t/3
\family default
 makes an asynchronous call to the ATS and further on to the specified transacti
on 
\family typewriter
Ref
\family default
 to update its state with the result from calling 
\family typewriter
Fun
\family default
 with its current state.
 As the call is asynchronous 
\family typewriter
update_t/3
\family default
 always returns immediately with 
\family typewriter
ok
\family default
 and the caller cannot be sure wether it was a successful update or not.
 If the function fails then the transaction gets aborted and any future
 query or commit calls to that transaction 
\family typewriter
Ref
\family default
 will forever return 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Standard
If the transaction was already aborted or the given 
\family typewriter
Ref
\family default
 does not exist then the update call is ignored.
\end_layout

\begin_layout Paragraph
commit_t(AT, Ref)
\end_layout

\begin_layout Standard
To commit a transaction 
\family typewriter
commit_t/2
\family default
 is used.
 It takes a process id 
\family typewriter
AT
\family default
 of an ATS, a transaction reference 
\family typewriter
Ref
\family default
 and tries to commit that transaction, i.e.
 update the state of the ATS with the state of 
\family typewriter
Ref
\family default
.
 If the given transaction has been aborted or does simply not exist, then
 
\family typewriter
aborted
\family default
 is returned.
\end_layout

\begin_layout Standard
If the commit was successful then the state of the ATS is updated to be
 the current state of the given transaction, followed by all current transaction
s being aborted, including the one that was committed.
 Meaning that with every successful commit every transaction is aborted,
 and all future action on any previous transaction will return aborted,
 or ignored if the action is 
\family typewriter
update_t/3
\family default
, and the ATS is at a 'clean' state
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What do I mean by this, clean state?
\end_layout

\end_inset

.
 The assignment text specifies several times that all the 
\emph on
other
\emph default
 transactions must aborted when doing a successful commit, but it also states
 that committing an already successfully committed transaction must return
 
\family typewriter
aborted
\family default
, inclining that this transaction has been aborted or will be aborted no
 matter what, and therefore I choose that it must be aborted after it has
 been committed.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
 I did consider that the reason that the extra commit would return aborted
 was that the transaction had been started from an obsolete and outdated
 state, 
\end_layout

\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

I have chosen to make 
\family typewriter
commit/2
\family default
 a synchronous call to the ATS to let it be possible to return the proper
 return value to the caller, and to lock the master while he is committing
 to try and disallow any outside interference.
\end_layout

\begin_layout Paragraph
get_pids(AT)
\end_layout

\begin_layout Standard

\family typewriter
get_pids/1
\family default
 is an interface function that I have added for the sake of testing, it
 makes a synchronous call to a given ATS and returns a list of process id
 over all the living processes that the given ATS is managing, including
 it self.
\end_layout

\begin_layout Subsubsection
Extended API
\end_layout

\begin_layout Standard
All the four functions of the extended API are blocking functions.
\end_layout

\begin_layout Paragraph
abort(AT, Ref)
\end_layout

\begin_layout Standard
This function forces a transaction 
\family typewriter
Ref
\family default
 to be aborted.
 I have implemented this functionality by querying the transaction with
 a function that always raises an error, as shown below in Figure 5.
\end_layout

\begin_layout LyX-Code
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout LyX-Code
abort(AT, Ref) ->
\end_layout

\begin_layout LyX-Code
    at_server:query_t(AT,Ref,fun(_) -> error(force_abort) end).
\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
My implementation of the Erlang function 
\family typewriter
abort/2
\family default
.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This forces the query function to fail and cause the transaction to be aborted.
\end_layout

\begin_layout Standard
By using 
\family typewriter
query_t/3
\family default
 I also cause the 
\family typewriter
abort/2
\family default
 function to block, i.e.
 by making a synchronous call to the server.
 I could have used 
\family typewriter
update_t/3
\family default
 with the same error-raising-function, and allow 
\family typewriter
abort/2
\family default
 to return immediately, this would though open up for the possibility that
 we could try and query, update or even commit the transaction successfully
 due to the nature of the message order, before our error-function is run
 and aborts the transaction.
 By using 
\family typewriter
query_t/3
\family default
 I can guarantee the caller that when 
\family typewriter
abort/2
\family default
 returns the transaction is indeed aborted.
\end_layout

\begin_layout Standard
I have defined the return value of 
\family typewriter
abort/2
\family default
 to be the return value of 
\family typewriter
query_t/3
\family default
, which implies that 
\family typewriter
abort/2
\family default
 can only return 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Paragraph
tryUpdate(AT, Fun)
\end_layout

\begin_layout Standard
As the name implies; 
\family typewriter
tryUpdate/2
\family default
 tries to update a specified ATS with the given function 
\family typewriter
Fun
\family default
, if the 
\family typewriter
Fun
\family default
 fails then error is returned but if a transaction is successfully updated
 with 
\family typewriter
Fun
\family default
 then the return value of 
\family typewriter
tryUpdate/2
\family default
 is the return value of the commit attempt.
\end_layout

\begin_layout Standard
To allow 
\family typewriter
tryUpdate/2
\family default
 to return 
\family typewriter
error
\family default
 if 
\family typewriter
Fun
\family default
 fails I start by querying the spawned transaction and checking the result.
 Then to avoid performing 
\family typewriter
Fun
\family default
 twice, as it may be expensive, the provided update function to the transaction
 is simply just a function that does not care about the previous state and
 merely returns the result from the query.
 Although this does add a slight unnecessary overhead of transporting the
 result from the query back and forth, but allows us to easily return 
\family typewriter
error
\family default
 when 
\family typewriter
Fun
\family default
 fails.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The tryUpdate/2 function starts by beginning a transaction within AT, then
 does the query and if it succeeds then the transaction is updated and at
 last committed.
\end_layout

\begin_layout Paragraph
ensureUpdate(AT, Fun)
\end_layout

\begin_layout Standard

\family typewriter
ensureUpdate/2
\family default
 takes a pid of an ATS and a function 
\family typewriter
Fun
\family default
 and promises to update the ATS with the function 
\family typewriter
Fun
\family default
 and return 
\family typewriter
ok
\family default
, except if 
\family typewriter
Fun
\family default
 fails, then 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
I felt that the assignment text was not clear of which state 
\family typewriter
ensureUpdate/2
\family default
 should update.
 As one can easily imagine the case of someone else making a commit before
 
\family typewriter
ensureUpdate/2
\family default
 is able to actual update a transaction and performing a commit, forcing
 the function to try again.
 But which state should 
\family typewriter
ensureUpdate/2
\family default
 now update, the new state of the ATS or the initial state that the AST
 had when 
\family typewriter
ensureUpdate/2
\family default
 was first called? I decided to go with the second case, as I felt that
 this would make most sense
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why?
\end_layout

\end_inset

.
 Although this approach would mean that we have to rollback those commits
 that snuck in while we were trying to update the state of the ATS, but
 this also allows us to only compute the function 
\family typewriter
Fun
\family default
 one time instead of recalculating it whenever we have to try again, because
 someone else made a commit before us, and if 
\family typewriter
Fun
\family default
 is expensive; this could go on for a very long time.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ensureUpdate/2
\family default
 starts by beginning a new transaction 
\family typewriter
T
\family default
 and then query 
\family typewriter
T
\family default
 with 
\family typewriter
Fun
\family default
, if the result is aborted then I conclude that 
\family typewriter
Fun
\family default
 failed and return 
\family typewriter
error
\family default
.
 If some new state 
\family typewriter
S
\family default
 was returned start a loop function 
\family typewriter
ensureLoop/2
\family default
 that will keep trying to update the state of the ATS to be 
\family typewriter
S
\family default
, until it succeeds.
 This ensures that it was the initial state of the ATS that is updated and
 not the in-between committed states.
\end_layout

\begin_layout Paragraph
choiceUpdate(AT, Fun, Val_list)
\end_layout

\begin_layout Standard

\family typewriter
choiceUpdate/3
\family default
 takes, as always, a pid for an ATS, a function 
\family typewriter
Fun(State,E)
\family default
 and a list of element 
\family typewriter
Val_list
\family default
, where 
\family typewriter
State
\family default
 is the state of the ATS and 
\family typewriter
E
\family default
 is an element from 
\family typewriter
Val_list
\family default
.
 
\family typewriter
choiceUpdate/3
\family default
 then tries for each element in 
\family typewriter
Val_list
\family default
 to update the state of the ATS with 
\family typewriter
Fun
\family default
 in parallel.
 The first one to finish its update function is also the one that 
\family typewriter
choiceUpdate/3
\family default
 tries to commit and the return value is then the return value from that
 commit.
 If all update functions fail then 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
It is assumed that 
\family typewriter
Val_list
\family default
 is indeed a list.
\end_layout

\begin_layout Standard
The function starts by beginning an amount of transactions equal to the
 number of elements in 
\family typewriter
Val_list
\family default
.
 Then foreach of these transactions they are asked to update their state
 with 
\family typewriter
Fun
\family default
 and the respective element 
\family typewriter
E
\family default
.
 The update function has been altered to include a try and catch around
 
\family typewriter
Fun
\family default
, which makes sure to send the correct message back to us.
 We then enter a loop function called 
\family typewriter
choiceLoop/2
\family default
 where we wait for the first transaction to succeed its update function
 or that all transactions failed to update their state.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
An important and somewhat trivial aspect of 
\family typewriter
choiceUpdate/3
\family default
 is that all the transactions must have been begun before any one of them
 starts updating otherwise one transaction might have finished its update
 function before another had even been created.
 Therefore all are begun before any one is asked to update, to ensure a
 greater fairness to each transaction.
 Of course running through the list and asking each to update one by one,
 also favors the first transactions in the list, but this is how far the
 fairness is possible to stretch in this case.
\end_layout

\begin_layout Standard
Parallelism is achieved by utilizing that 
\family typewriter
update_t/3
\family default
 is called asynchronously, and that each transaction runs in its own process.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The assignment text specifies that 
\family typewriter
choiceUpdate/3
\family default
 must return the value of the commit of the first transaction to update
 successfully, but this is not possible if none update succeeds.
 Instead of letting the function hang and wait forever for some transaction
 to update successfully, I have added the try-catch inside the update function
 to be able to let 
\family typewriter
choiceUpdate/3
\family default
 know if some transaction was aborted and ultimately allowing it to know
 if all fail and then return 
\family typewriter
error
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
There is also the slight chance that someone else makes a commit before
 any of our transactions gets through, 
\family typewriter
choiceUpdate/3
\family default
 will still could the commit with the first successful transaction to update,
 if any, but as implied the return value would then be 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
As one may have noticed if glanced upon my implementation, I associate an
 unique reference to each call to choiceUpdate/3 this is because in a previous
 call to to choiceUpdate/3 one of the transactions may be still working
 on its update function, and if it finishes while a future choiceUpdate/3
 call is waiting for responds from its own transactions then this old one
 while interfere and send 'false' messages to the choiceUpdate/3, by associated
 a unique reference to each session allows the function to discard any old
 obsolete messages.
\end_layout

\begin_layout Subsubsection
Callback functions
\end_layout

\begin_layout Standard
The 
\family typewriter
format_status/2
\family default
 function is not used, and as it is an optional callback function I have
 not implemented it.
\end_layout

\begin_layout Standard
Some of the callback functions are rather big and mixed with callbacks to
 both the ATS, transactions and both, therefore when describing some of
 these I will divide them into the three cases ATS, Transaction and Both
 equal to their separation in the actual file 
\emph on
at_server.erl
\emph default
, to try and make it more readable.
\end_layout

\begin_layout Paragraph
init(Args)
\end_layout

\begin_layout Standard
The 
\family typewriter
init/1
\family default
 function is called by the 
\emph on
gen_server
\emph default
 when an atomic server or a transaction must be spawned.
 It is used to set the init state of the created server.
\end_layout

\begin_layout Standard
When an ATS is being created from the 
\family typewriter
start/1
\family default
 interface function, then I have wrapped the initial given 
\family typewriter
State
\family default
 in a tuple with the atom 
\family typewriter
server
\family default
 as the first element to know this in the init function and set the init
 pool size to be an empty list.
\end_layout

\begin_layout Standard
If a new transaction is being created by the ATS then the atom 
\family typewriter
transaction
\family default
 is passed along in the same fashion as 
\family typewriter
server
\family default
 and the initial status is set to 
\family typewriter
ready
\family default
.
\end_layout

\begin_layout Paragraph
handle_call/3
\end_layout

\begin_layout Standard

\family typewriter
handle_call/3
\family default
 is called by the 
\emph on
gen_server
\emph default
 when a synchronous request is send to the server.
 Here I have split the description into the three parts.
\end_layout

\begin_layout Subparagraph
ATS
\end_layout

\begin_layout Standard
If the 
\family typewriter
stop_at_server
\family default
 request is send to an ATS then it propagates the stop request to all the
 transactions that it manages, before terminating it self with the reason
 
\family typewriter
normal
\family default
, and the reply 
\family typewriter
{ok,State}
\family default
 where 
\family typewriter
State
\family default
 is the current state of the ATS.
\end_layout

\begin_layout Standard
When a 
\family typewriter
{doquery_t, {Ref, Fun}}
\family default
 request is received then the ATS looks 
\family typewriter
Ref
\family default
 up in its table of transactions, if it exist and has the status 
\family typewriter
ready
\family default
 then we try to query the transaction with the given 
\family typewriter
Fun
\family default
, if it returns 
\family typewriter
error
\family default
 then we remove it from our pool of transactions or mark it state to be
 
\family typewriter
aborted
\family default
 and reply 
\family typewriter
aborted
\family default
, if not then we return the result.
 If the look up failed then we also reply 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Standard
If an ATS received a 
\family typewriter
begin_t
\family default
 query then it creates a unique reference and then tries to find an idle
 transaction within its pool, which it then initializes to be an fresh and
 ready transaction to be used.
 If no transaction was found, then a new one is started/spawned and the
 ATS adds it to its pool, at last the unique reference is then replied to
 the caller.
\end_layout

\begin_layout Standard
When 
\family typewriter
{commit_t, Ref}
\family default
 is received then the ATS starts by look up in its pool if the 
\family typewriter
Ref
\family default
 is present and in 
\family typewriter
ready
\family default
 status, if it is found then the transaction is queried for its state 
\family typewriter
S
\family default
 and if the transaction has not been aborted then the state of the ATS is
 updated to be 
\family typewriter
S
\family default
, and all transactions are either killed or given the 
\family typewriter
idle
\family default
 status.
 
\family typewriter
aborted
\family default
 is replied if the look up failed or if the 
\family typewriter
doquery
\family default
 request returned 
\family typewriter
error
\family default
.
\end_layout

\begin_layout Standard
If the 
\family typewriter
get_pid
\family default
 request is received then the ATS replies with all process ids found in
 its pool and includes its own.
\end_layout

\begin_layout Subparagraph
Transaction
\end_layout

\begin_layout Standard
A transaction can receive an 
\family typewriter
initialize
\family default
 request along with some 
\family typewriter
InitState
\family default
 value, this forces the transaction to update its entire state data with
 the value of 
\family typewriter
InitState
\family default
.
 The transaction can also receive a 
\family typewriter
stop_at_trans
\family default
 request which forces the transaction to stop, i.e.
 shutdown with the reason 
\family typewriter
normal
\family default
.
 If the transaction receive a 
\family typewriter
doquery
\family default
 request but has the aborted status then it ignores the request and replies
 with 
\family typewriter
aborted
\family default
.
 The case where it does not have the 
\family typewriter
aborted
\family default
 status is described below.
\end_layout

\begin_layout Subparagraph
Both
\end_layout

\begin_layout Standard
Both an ATS and a transaction can receive a 
\family typewriter
{doquery, Fun}
\family default
 request and if so then 
\family typewriter
Fun
\family default
 is computed with the current state and the result is replied back to the
 sender, if the function fails then we catch this and reply with 
\family typewriter
error
\family default
 instead.
 We do not update the state of the ATS or transaction.
\end_layout

\begin_layout Standard
I have added a generic case to make sure that any unexpected request is
 simply just ignored instead of crashing the server.
\end_layout

\begin_layout Paragraph
handle_cast/2
\end_layout

\begin_layout Standard
When ever an asynchronous request is sent to the server then the 
\family typewriter
handle_cast/2
\family default
 callback is called by the OTP.
\end_layout

\begin_layout Subparagraph
ATS
\end_layout

\begin_layout Standard
When an ATS received the request 
\family typewriter
{update_t, {Ref, Fun}}
\family default
 it will try to look up the given 
\family typewriter
Ref
\family default
 in its pool of transactions if it exists and is 
\family typewriter
ready
\family default
, meaning that it has not been aborted before and do exist, then the ATS
 sends an asynchronous update request to the transaction with the given
 function 
\family typewriter
Fun
\family default
.
 The state and pool of the ATS is not altered in any way.
\end_layout

\begin_layout Subparagraph
Transaction
\end_layout

\begin_layout Standard
If an aborted transaction receives an update request 
\family typewriter
{update, Fun}
\family default
 then the request is just ignored.
 If it is in the 
\family typewriter
ready
\family default
 status then it tries to perform the update and if the function 
\family typewriter
Fun
\family default
 fails then its state is not updated but its status is set to 
\family typewriter
aborted
\family default
.
 If the function succeeds then the state is updated to be the result of
 the function and the status remains unchanged.
\end_layout

\begin_layout Standard
A transaction can also be asynchronously asked to stop with the 
\family typewriter
stop_at_trans
\family default
 messages, and so it will.
\end_layout

\begin_layout Subparagraph
Both
\end_layout

\begin_layout Standard
Also here is a generic case added to make sure that any unexpected request
 is simply just ignored instead of crashing the server.
\end_layout

\begin_layout Paragraph
handle_info(Info, State)
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://www.erlang.org/doc/man/gen_server.html#Module:handle_info-2
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I do not utilize this function.
\end_layout

\begin_layout Paragraph
terminate(Reason, State)
\end_layout

\begin_layout Standard

\family typewriter
terminate/2
\family default
 is called by the 
\emph on
gen_server
\emph default
 right before the process is killed allowing you to do some clean up before
 shutdown.
 As already mentioned I have decided to do this in 
\family typewriter
handle_call/3
\family default
.
 Although if the ATS is terminated for some unexpected reason then I must
 try to stop any ongoing transactions incase it is the ATS that is being
 terminated.
 I the reason is 
\family typewriter
normal
\family default
 then I assume that everything is under control.
\end_layout

\begin_layout Paragraph
code_change(OldVsn, State, Extra)
\end_layout

\begin_layout Standard
The function 
\family typewriter
code_change/3
\family default
 is not used nor implemented to any extend beyond some mere default state
 as the 
\emph on
gen_server
\emph default
 behavior expects this callback function to be implemented.
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
ensureLoop(AT, Fun)
\end_layout

\begin_layout Standard
Takes a pid of an ATS and a function 
\family typewriter
Fun
\family default
.
 It begins a transaction, updates it with 
\family typewriter
Fun
\family default
 and tries to commit.
 If the commit succeeds then it returns 
\family typewriter
ok
\family default
, if not then it will try again.
 The function assumes that 
\family typewriter
Fun
\family default
 never fails, and will only stop looping when a commit was successful.
\end_layout

\begin_layout Paragraph
choiceLoop(AT, AllTrans)
\end_layout

\begin_layout Standard

\family typewriter
choiceLoop/2
\family default
 takes an ATS and a list of tuples 
\family typewriter
AllTrans
\family default
 where it assumes that the first element each tuple is of type 
\family typewriter
{ok,Ref}
\family default
 where 
\family typewriter
Ref
\family default
 is some transaction reference.
 If 
\family typewriter
AllTrans
\family default
 is empty then 
\family typewriter
error
\family default
 is returned, otherwise it will listen for the messages 
\family typewriter
{R,done}
\family default
, 
\family typewriter
{R,error}
\family default
 and 
\family typewriter
E
\family default
, where the first message indicates that 
\family typewriter
R
\family default
 is done with its update function and must be committed, and the return
 value of this commit is returned to the caller.
 If the error message is received then the reference is removed from 
\family typewriter
AllTrans
\family default
 and the loop is called once again.
 If some unexpected message 
\family typewriter
E
\family default
 is received then this is discarded and the loop function is called recursively.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
It is assumed that the first instance of 
\family typewriter
{R,done}
\family default
 is also the first to update its state, even though this cannot be completely
 guaranteed due to the process communication.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix A Tests
\end_layout

\begin_layout Subsection
Question 1 Testing
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
When do I consider my implementation to be correct/ working as intended?
 Write it somewhere.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Testing of the parser implemented in the file 
\emph on
SalsaParser.hs
\emph default
 is done through the module 
\family typewriter
Test_Parser
\family default
 implemented in the file 
\emph on
Test_Parser.hs
\emph default
.
 I decided to only test my implementation through the interface of the 
\family typewriter
SalsaParser
\family default
 module.
 
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Why ? And why not also the individual parser.
 -> They are very simple..
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection

\emph on
Test_Parser.hs
\end_layout

\begin_layout Standard
This test file implements the module 
\family typewriter
Test_Parser
\family default
 which exports the function 
\family typewriter
runAllTests()
\family default
 and 
\family typewriter
runAllTestsWith(n)
\family default
, where n is the number of 
\emph on
QuickCheck
\emph default
 test cases, 
\begin_inset Formula $100$
\end_inset

 is the default value.
 This test file uses both 
\emph on
QuickCheck
\emph default
 and 
\emph on
HUnit
\emph default
.
\end_layout

\begin_layout Standard
The test file is divided into three parts; a 
\emph on
QuickCheck
\emph default
 part, testing the parser with a valid input string, a 
\emph on
HUnit
\emph default
 part testing parsing of invalid input strings and that the correct precedence
 and associativity is maintained and a the third part testing that the parsing
 of files works as intended.
\end_layout

\begin_layout Paragraph
Part 1
\end_layout

\begin_layout Standard
The QuickCheck part defines a set of lists containing definitions of the
 different components of the Salsa grammar, not to be confused with the
 Salsa definitions described in the grammar.
 These are used when picking a random element to generate, when generating
 the different components.
 The generated test cases tend to get rather big and slow down the test
 I have therefore added a few more cases of 
\begin_inset Quotes eld
\end_inset

move
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

const
\begin_inset Quotes erd
\end_inset

 respectively to the lists commands and exprList to easily add a greater
 chance that the generated data won't grow to large.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The test checks that any
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Of course not all possible input values but a random subset of the possible
 input each time the test is run.
\end_layout

\end_inset

 valid input string is parsed to the correct abstract syntax tree.
 When generator a test case then nothing is predefined, all values are random
 generated by 
\family typewriter
QuickCheck Gen 
\family default
monad so everything is tested, although each value is restricted to be a
 valid value, and every command and expr is within parenthesis meaning that
 this test does not test for precedence or associativity of the operators.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use verbose and comment on the generated data, is it good enough?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
So far the tests keeps succeeding every time I run it.
 Based on this I assume that it works for any valid input string, but not
 precedence and associativity.
\end_layout

\begin_layout Paragraph
Part 2
\end_layout

\begin_layout Standard
This part defines a lot of HUnit tests.
 These are divided into two categories: eleven precedence cases and forty-one
 error cases.
\end_layout

\begin_layout Standard
As these are unit tests I will only test a small subset of input area in
 the individual tests, but based on these tests I assume that it also works
 for the whole area
\begin_inset Note Note
status open

\begin_layout Plain Layout
rephrase?
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Precedence
\end_layout

\begin_layout Standard
The first five precedence test cases shows that the operators '@', '||','+'
 and '-' are all left associative.
\end_layout

\begin_layout Standard
The next two show that '@' has higher precedence than '||'.
\end_layout

\begin_layout Standard
Test eight and nine show that '+' and '-' has the same precedence and therefore
 it is the order that matters, even though the end result will be the same
 as + and - in themselves are commutative.
\end_layout

\begin_layout Standard
The last two shows that '.' has higher precedence than both '+' and '-'.
\end_layout

\begin_layout Subparagraph
Error
\end_layout

\begin_layout Standard
The first test shows that an empty string cannot be parsed to anything and
 is therefore not a valid input string.
\end_layout

\begin_layout Standard
The next five tests that a sident cannot be used where a vident is expected.
\end_layout

\begin_layout Standard
Test case seven to eleven shows that a vident cannot be used in place of
 a sident.
\end_layout

\begin_layout Standard
The next four tests shows some of the invalid characters that cannot be
 used in a Salsa program.
\end_layout

\begin_layout Standard
The next two test cases tests that numbers cannot be used as vidents or
 sidents.
\end_layout

\begin_layout Standard
The following two tests shows that letters cannot be used in place of numbers.
\end_layout

\begin_layout Standard
Test case twenty to twenty-two show that not any parenthesis or brackets
 can be used when surrounding a command, group or point.
\end_layout

\begin_layout Standard
The next three test cases shows some of the unsupported operators that does
 not work for the Salsa language.
\end_layout

\begin_layout Standard
The next four tests shows that a reserved word nor a colour can be used
 in place of a sident.
\end_layout

\begin_layout Standard
The thirtieth test case shows that a colour must be one of the specified
 colour names.
\end_layout

\begin_layout Standard
Test next four test cases shows that with lacking white spaces you either
 get an error or an unexpected program.
\end_layout

\begin_layout Standard
Test number 35 shows that when defining a group the given list must be non-empty.
\end_layout

\begin_layout Standard
Test case number 36 to 38 show that the Salsa language is case-sensitive.
\end_layout

\begin_layout Standard
The next two test cases show that negative integers are not supported by
 the grammar.
\end_layout

\begin_layout Standard
The last test show that the above restriction can be bypassed by simply
 creating a expression that subtracts a number from a smaller number, which
 would produce a negative integer when executed.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

All these tests return the expected result and I therefore assume that precedenc
e and associativity works as intended and adheres to the grammar, furthermore
 that the parser returns expected error with a given invalid input string.
\end_layout

\begin_layout Paragraph
Part 3
\end_layout

\begin_layout Standard
This third part contains a set of five unit tests for testing the 
\family typewriter
parseFile
\family default
 function and that it works as intended, it works as intended when parsing
 the content of the file with 
\family typewriter
parseString
\family default
 yields the same result as parsing the file with 
\family typewriter
parseFile
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test shows that an empty file is parsed as expected.
\end_layout

\begin_layout Standard
The second and the third test shows that valid Salsa files are also parsed
 as expected.
\end_layout

\begin_layout Standard
The fourth test shows that a invalid Salsa file is parsed as expected.
\end_layout

\begin_layout Standard
The fifth test case show that when parsing a file that does not exist then
 it returns the expected IO exception.
 Note that if the file do exist for some reason then this test will acts
 as a test on the content instead.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Based on these few simple tests that returned the expected values, I assume
 that function 
\family typewriter
parseFile
\family default
 works as intended.
\end_layout

\begin_layout Paragraph
Conclusion
\end_layout

\begin_layout Standard
Furthermore based on the tests described above and that they all return
 the expected results, I assume that my grammar and my implementation of
 the 
\family typewriter
SalsaParser
\family default
 module works as intended.
\end_layout

\begin_layout Subsection
Question 2 Testing
\end_layout

\begin_layout Standard
To test my implementation of the Salsa interpreter defined in the module
 
\emph on
SalsaInterp
\emph default
 I have implemented a QuickCheck test to do so in the file 
\emph on
Test_Interp.hs
\emph default
 which defines and implements the module 
\emph on
Test_Interp
\emph default
.
 This module exports two functions 
\family typewriter
runAllTestsI()
\family default
 and 
\family typewriter
runAllTestsIWith(n)
\family default
.
 Each run the same QuickCheck test but 
\family typewriter
runAllTestsIWith(n)
\family default
 allows you to specify the number of test cases to run.
 The default is set to 
\begin_inset Formula $100$
\end_inset

.
\end_layout

\begin_layout Standard
I am aware that 
\emph on
hlint
\emph default
 spits out a hint of 
\begin_inset Quotes eld
\end_inset

Reduce duplication
\begin_inset Quotes erd
\end_inset

 but as in the other files I believe it would hurt the readability to resolve
 it.
\end_layout

\begin_layout Subsubsection

\emph on
Test_Interp.hs
\end_layout

\begin_layout Standard
As I can assume that the interpreter should not concern much of errors and
 wrong input, then this will not be a focus in my test.
\end_layout

\begin_layout Standard
My test file is divided into two sections; a 
\emph on
QuickCheck
\emph default
 part and a 
\emph on
HUnit
\emph default
 part, I therefore find it adequate to divide my test description into two
 parts as well.
\end_layout

\begin_layout Paragraph
Part 1
\end_layout

\begin_layout Standard
I have defined a type 
\family typewriter
TestAnimation
\family default
 which becomes an instance 
\family typewriter
QuickCheck.Arbitrary
\family default
 and generates a valid Salsa Program 
\family typewriter
p
\family default
 along with the expected Animation output from interpreting 
\family typewriter
p
\family default
.
 I do not intend to go in depth of the generator functions nor helper functions
 here, instead I want to describe my results.
\end_layout

\begin_layout Standard
The generated programs do not contain any Par commands and do not generate
 At commands that specify a group identifier.
 It does neither use Xproj or Yproj as expressions.
\end_layout

\begin_layout Standard
With that said then it works rather and and returns the expected results
 with every run.
\end_layout

\begin_layout Paragraph
Part 2
\end_layout

\begin_layout Standard
This part is a set of 
\emph on
HUnit
\emph default
 test cases that tests the missing functionality from 
\series bold
Part 1
\series default
.
\end_layout

\begin_layout Standard
The first set of tests tests the 
\family typewriter
Par
\family default
 command.
 The case is very simple yet the expected result is returned.
\end_layout

\begin_layout Standard
The second case tests that the 
\family typewriter
At
\family default
 command and 
\family typewriter
Group
\family default
 definition works in the same program.
\end_layout

\begin_layout Standard
The third case tests that the 
\family typewriter
Xproj
\family default
 and 
\family typewriter
Yproj
\family default
 expressions work as intended.
\end_layout

\begin_layout Standard
The fourth set of tests show that the interpolate function returns the expected
 results.
\end_layout

\begin_layout Paragraph
Conclusion
\end_layout

\begin_layout Standard
As my 
\emph on
QuickCheck
\emph default
 property holds for all Salsa 
\family typewriter
Programs
\family default
 without the 
\family typewriter
Par
\family default
 command at 
\family typewriter
At
\family default
 commands with group identifiers I assume that that part of my Salsa interpreter
 works as intended.
 Furthermore based on the unit tests that try to cover what 
\emph on
QuickCheck
\emph default
 left behind, which are somewhat scraped to a very few number of tests due
 to a approaching deadline, I (almost) dare to assume that the rest of my
 Salsa interpreter also works as intended.
\end_layout

\begin_layout Subsection
Question 3 Testing
\end_layout

\begin_layout Standard
The following is my tests for the atomic transaction server.
 I have created a single file 
\emph on
test_at_server.erl
\emph default
 and module 
\emph on
test_at_server
\emph default
 that tests the interface functions of the server and the extra API functions.
 The module exports the function 
\family typewriter
runTests/0
\family default
 that runs all the tests.
\end_layout

\begin_layout Standard
I decided to let each test section focus on a single interface/API function
 at a time, and I will use the same distinction when describing my tests
 here.
\end_layout

\begin_layout Standard
I assume that no one tries to manipulate the servers nor transactions while
 I test them.
\end_layout

\begin_layout Subsubsection

\emph on
test_at_server.erl
\end_layout

\begin_layout Paragraph
testStart()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function test the functionality of 
\family typewriter
start/1
\family default
 with two test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test shows that we can start a server with some partly-random
 state value and that this is alive.
\end_layout

\begin_layout Standard
The second test shows that multiply servers can be started as expected.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Based on the two test cases I assume that my implementation of 
\family typewriter
start/1
\family default
 works as intended.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Did they work as intended?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
testBegin()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
testbegin/0
\family default
 test the function 
\family typewriter
begin_t/1
\family default
 with four test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test shows that only one process is alive at start up.
\end_layout

\begin_layout Standard
Then the second test case tests that the number of living processes increase
 with the amount of transactions begun.
\end_layout

\begin_layout Standard
Test three shows that a transaction created with an ATS 
\family typewriter
A
\family default
 cannot be used within another ATS.
\end_layout

\begin_layout Standard
The fourth test shows that the state of a not-updated transaction is the
 same as the ATS.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Based on this I assume that 
\family typewriter
begin_t/1
\family default
 works as intended.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Did they work as intended?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
testStop()
\end_layout

\begin_layout Standard
Here we test that 
\family typewriter
stop/1
\family default
 returns all processes within a given ATS is stopped.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test tests that an ATS with no ongoing transactions is stopped
 after calling the stop function.
\end_layout

\begin_layout Standard
The second test shows that an ATS with multiply ongoing transactions are
 also stopped as expected if calling 
\family typewriter
stop/1
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Based on these two simple test cases I assume that my implementation of
 
\family typewriter
stop/1
\family default
 works as intended.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Did they work as intended?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
testDoquery()
\end_layout

\begin_layout Standard
Here we test the 
\family typewriter
doquery/2
\family default
 API function.
 The intended functionality is that when provided with a function 
\family typewriter
F
\family default
 it returns the same value as if 
\family typewriter
F
\family default
 was run locally on the same state, that it does not update the state of
 the ATS and that if the function fails 
\family typewriter
error
\family default
 is returned and the process is unchanged.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first two test cases show that the query with a function 
\family typewriter
F
\family default
 returns the same as running 
\family typewriter
F
\family default
 locally.
\end_layout

\begin_layout Standard
The third test shows that the state of the ATS has not been changed.
\end_layout

\begin_layout Standard
The last test tests that if queried with some error-prone function then
 
\family typewriter
error
\family default
 is returned and the ATS remains unchanged.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Based on these test I assume that 
\family typewriter
doquery/2
\family default
 works as intended.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Did they work as intended?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
testQuery_t()
\end_layout

\begin_layout Standard
Here I test the 
\family typewriter
query_t/3
\family default
 function with seven test cases.
 I expect that if queried with a function 
\family typewriter
F
\family default
 then the result is the same as evaluating 
\family typewriter
F
\family default
 locally, that 
\family typewriter
query_t/3
\family default
 does not update the state of the transaction except if it fails, in which
 case would return aborted and the transaction remains aborted.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first two test cases tests that if queried with a function 
\family typewriter
F
\family default
 then the result is the same as using 
\family typewriter
F
\family default
 locally.
\end_layout

\begin_layout Standard
The third case shows that the state of the queried transaction is unchanged.
\end_layout

\begin_layout Standard
The fourth case shows that if run with a function that will fail then 
\family typewriter
aborted
\family default
 is returned as expected.
\end_layout

\begin_layout Standard
Test case five then tests that the transactions remains aborted if queried
 again.
\end_layout

\begin_layout Standard
Test six tests that if another transaction was started earlier then this
 remains intact.
\end_layout

\begin_layout Standard
The seventh test case tests that if a query is sent to some non-existing
 transaction then 
\family typewriter
aborted
\family default
 is returned as expected.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
All seven test cases works as expected and based on this I assume that my
 implementation of 
\family typewriter
query_t/3
\family default
 works as intended.
\end_layout

\begin_layout Paragraph
testUpdate_t()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With five test cases I test that my implementation of 
\family typewriter
update_t/3
\family default
 works as intended.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test case tests that if we update some transaction with a function
 
\family typewriter
F
\family default
 then its state is updated to be the result of 
\family typewriter
F
\family default
 and this works as expected.
\end_layout

\begin_layout Standard
The second test that if the given function fails then the transaction is
 aborted.
\end_layout

\begin_layout Standard
The third case test that if trying to update an already aborted transaction
 yields no change to the status of the transaction.
\end_layout

\begin_layout Standard
The fourth test tests that even though one transaction has been aborted
 then previous begun transactions are still working.
\end_layout

\begin_layout Standard
The fifth and last test case show that if calling update with a unrecognized
 transaction reference then no change has happened.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The above five tests return the expected results and I therefore assume
 that my implementation of update_t/3 works as intended.
\end_layout

\begin_layout Paragraph
testCommit_t()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function tests my implementation of 
\family typewriter
commit_t/3
\family default
 with six test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test case tests that you do not need to update a transaction before
 commit it as expected the commit is successful and the state of the ATS
 remains the same.
\end_layout

\begin_layout Standard
The second test case show the transaction used before has now been aborted,
 and that trying to commit that transaction again returns 
\family typewriter
aborted
\family default
 and it remains aborted.
\end_layout

\begin_layout Standard
Third test case tests that if a transaction is updated before being committed
 then the updated state becomes the new state of the ATS.
\end_layout

\begin_layout Standard
The fourth test case show that if the provided update function failed then
 when trying to commit the transaction 
\family typewriter
aborted
\family default
 is returned.
\end_layout

\begin_layout Standard
The fifth test case tests that we can have several transactions going and
 if one is successfully committed then all are aborted and the state of
 ATS is updated to the expected one.
\end_layout

\begin_layout Standard
The last test case tests that 
\family typewriter
aborted
\family default
 is returned if trying to call 
\family typewriter
commit_t/3
\family default
 with a wrong transaction reference.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
All six test cases return the expected values and based on this I assume
 that my implementation of 
\family typewriter
commit_t/3
\family default
 is correct and works as intended.
\end_layout

\begin_layout Paragraph
testAbort()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family typewriter
abort/2
\family default
 is tested in this function with five test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test case tests that 
\family typewriter
aborted
\family default
 is returned if calling 
\family typewriter
abort/2
\family default
 on some transaction that has been started.
\end_layout

\begin_layout Standard
The second test show that 
\family typewriter
aborted
\family default
 is returned if calling 
\family typewriter
abort/2
\family default
 on some transaction that has been aborted previously.
\end_layout

\begin_layout Standard
The third show that several ongoing transactions can be aborted without
 trouble.
\end_layout

\begin_layout Standard
The fourth test case tests that no one else is affected when one is aborted.
\end_layout

\begin_layout Standard
The fifth test case tests that 
\family typewriter
aborted
\family default
 is also returned if called with an unknown transactions reference.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
All of the five test cases return the expected results and therefore I assume
 that 
\family typewriter
abort/2
\family default
 work as intended.
\end_layout

\begin_layout Paragraph
testTryUpdate()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function tests the functionality of my implementation of 
\family typewriter
tryUpdate/2
\family default
 with four test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first one shows that if no other transaction has been started then 
\family typewriter
tryUpdate/2
\family default
 successfully updates the given ATS.
\end_layout

\begin_layout Standard
The second test case shows that if the function fails then error is returned
 and the state of the ATS remains unaltered.
\end_layout

\begin_layout Standard
The third case tests that if other transactions have been begun, then these
 are aborted if 
\family typewriter
tryUpdate/2
\family default
 succeeds.
\end_layout

\begin_layout Standard
The last case tries to test that if someone else gets to sneak a commit
 in while 
\family typewriter
tryUpdate/2
\family default
 is trying to update the state, then 
\family typewriter
aborted
\family default
 is returned.
 Note that I wrote 'tries to' as this is very hard to test due to my implementat
ion of 
\family typewriter
tryUpdate/2
\family default
 as clearly a transaction who is waiting only 
\emph on
500ms
\emph default
 should be able to get his commit through before 
\family typewriter
tryUpdate/2
\family default
 who waits 
\emph on
3500ms
\emph default
.
 Since 
\family typewriter
tryUpdate/2
\family default
 blocks the ATS by using 
\family typewriter
query_t/3
\family default
 to do the computation, disallowing the previous transaction to commit after
 
\emph on
500ms
\emph default
.
 It seems like that once the query is done, then the other transaction is
 not allowed to commit as 
\family typewriter
tryUpdate/2
\family default
 is allowed to commit unbothered.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Even though the last test case is hard to set up, I believe that my implementati
on works as intended as it can either return 
\family typewriter
error
\family default
 or the return value from the commit statement which can be 
\family typewriter
ok
\family default
 or 
\family typewriter
aborted
\family default
, as shown earlier, and hence 
\family typewriter
tryUpdate/2
\family default
 will also return 
\family typewriter
aborted
\family default
 in the case that the commit returns 
\family typewriter
aborted
\family default
.
 With this in mind and the fact that the other test cases returned the expected
 result I assume that my implementation of 
\family typewriter
tryUpdate/2
\family default
 works as intended.
\end_layout

\begin_layout Paragraph
testEnsureUpdate()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As my naming convention might have revealed by now, this function tests
 my implementation of 
\family typewriter
ensureUpdate/2
\family default
, and does so with three test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first case tests that if no other transaction has been begun, 
\family typewriter
ensureUpdate/2
\family default
 returns 
\family typewriter
ok
\family default
 and the state of the ATS is updated accordingly.
\end_layout

\begin_layout Standard
The second case tests that if the given function fails then 
\family typewriter
error
\family default
 is returned and the state of the ATS remains unchanged.
\end_layout

\begin_layout Standard
The third test case has the intention to show that if someone gets to commit
 before 
\family typewriter
ensureUpdate/2
\family default
, but after it has begun trying, then it will try again, and eventually
 rollback the other commit.
 But it doesn't work presumably of the query call in 
\family typewriter
ensureUpdate/2
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Based on these three simple test cases I assume that 
\family typewriter
ensureUpdate/2
\family default
 works as expected.
\end_layout

\begin_layout Paragraph
testChoiceUpdate()
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
What is the expected/intended behaviour?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
My last test function tests the functionality of the 
\family typewriter
choiceUpdate/3
\family default
 function with six test cases.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first case tests that no other transactions has been begun and 
\family typewriter
choiceUpdate/3
\family default
 is run with a single element, then this gets through, 
\family typewriter
ok
\family default
 is returned and the AST has been updated.
\end_layout

\begin_layout Standard
The second test case tests that if all choices fail with their function
 except one, then this one gets through, 
\family typewriter
ok
\family default
 is returned and the AST is correctly updated.
\end_layout

\begin_layout Standard
The third case tests that the shorter function of two is the one who is
 chosen and gets to be committed to be AST.
 Although due to the internal workings of the OS, Erlang environment and
 the alike, I cannot guarantee that this case will always return the expected
 result, but I do dare to say that a process waiting 
\emph on
500ms
\emph default
 should only in the most strangest cases be allowed to (busy)wait all 
\emph on
500
\emph default
 before a process only waiting 
\emph on
1ms
\emph default
 gets scheduled to run and eventually make its commit.
\end_layout

\begin_layout Standard
The fourth test case tests that if someone else gets to commit before any
 of the choices have successfully updated their state then the return value
 is 
\family typewriter
aborted
\family default
 and 
\family typewriter
choiceUpdate/3
\family default
 does not get to update the AST.
\end_layout

\begin_layout Standard
The fifth case shows that if all choices fail then 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
The sixth and last test case tests that if the given list is empty then
 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
All the above functions return the expected result and based on this I assume
 that my implementation works as intended (big surprise).
\end_layout

\begin_layout Paragraph
Conclusion
\end_layout

\begin_layout Standard
Apart from some anal edge cases that I cannot provide the correct environment
 for, all my tests return the expected results and behave as intended, and
 I therefore dare to assume once more that my implementation the the 
\emph on
at_server 
\emph default
and 
\emph on
at_extapi
\emph default
 modules work as intended.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix B Grammar
\end_layout

\begin_layout Subsection
G0
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | Command ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command ’||’ Command
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsection
G1
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsection
G2
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr Rest2 .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’x’
\end_layout

\begin_layout LyX-Code
    | ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsection
G3
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command2 Command' .
\end_layout

\begin_layout LyX-Code
Command' ::= ’||’ Command2 Command'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command3 Command2' .
\end_layout

\begin_layout LyX-Code
Command2' ::= ’@’ VIdent Command2'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim Expr' .
\end_layout

\begin_layout LyX-Code
Expr' ::= Rest2 Expr'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | ’.’ ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix C Grammar assumptions
\end_layout

\begin_layout Subsection
My assumptions on the grammar
\end_layout

\begin_layout Standard
All my assumptions for the grammar can be viewed Appendix D.
\end_layout

\begin_layout Standard
Some of the non-terminals in the grammar are not specified in the grammar,
 and only partly described in the assignment text.
 I will therefore list my assumptions and the definitions that I use in
 my implementation.
\end_layout

\begin_layout Subsubsection
Case sensitivity
\end_layout

\begin_layout Standard
I assume that Salsa is case sensitive.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(This should be given from all definition of 
\emph on
VIdent
\emph default
 and 
\emph on
SIdent
\emph default
)
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
integer
\end_layout

\begin_layout Standard
Is a non-negative integer number and can therefore be written with the following
 regular expression: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[0-9]^{+}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
VIdent
\end_layout

\begin_layout Standard
As the assignment text specifies then 
\emph on
VIdent
\emph default
 is a nonempty sequence of letters, digits and underscore, which starts
 with a uppercase letter and can therefore be written with the following
 regular expression:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[A-Z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
SIdent
\end_layout

\begin_layout Standard

\emph on
SIdent
\emph default
 is the same as a 
\emph on
VIdent
\emph default
 except it cannot be one of the reserved words, described below, and has
 to start with a lowercase letter, which can be described as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[a-z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
White spaces
\end_layout

\begin_layout Standard
White spaces are what most would expect, spaces, any tabs and newlines.
 As I am using ReadP I will let the the function skipSpaces
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-ParserCombinators-ReadP.html
\end_layout

\end_inset

 define the exact representation of white spaces.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The reserved words, color names, 
\emph on
VIdent
\emph default
, and 
\emph on
SIdent
\emph default
 are separated by at least one white space of any kind.
 Symbolic tokens are separated by 0 or more white spaces and so are symbolic
 tokens and alpha-numeric tokens from each other.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Rephrase?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reserved Words
\end_layout

\begin_layout Standard
The reserved words are: 'viewdef', 'rectangle', 'circle', 'group' and 'view'.
\end_layout

\begin_layout Subsubsection
Color Names
\end_layout

\begin_layout Standard
The names of the color are also considered to be reserved words and are
 the following: 'blue', 'plum', 'red', 'green' and 'orange'.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix D
\end_layout

\begin_layout Subsection
Context functions
\end_layout

\begin_layout Paragraph
createEmptyContext :: Integer -> Context
\end_layout

\begin_layout Standard
This initializes an empty context with the given Integer 
\family typewriter
n
\family default
 and returns it, where 
\family typewriter
n
\family default
 is the frame rate.
\end_layout

\begin_layout Paragraph
lookupViews :: Ident -> Environment -> [Ident]
\end_layout

\begin_layout Standard
This functions takes an 
\family typewriter
Ident
\family default
 
\family typewriter
k
\family default
 specifying either a 
\family typewriter
View
\family default
 or a 
\family typewriter
Group
\family default
 and an 
\family typewriter
Environment
\family default
 
\family typewriter
env
\family default
 and tries to lookup 
\family typewriter
k
\family default
 in 
\family typewriter
env
\family default
 and returns the list of views the lookup returned.
\end_layout

\begin_layout Standard
The function assumes that the given 
\family typewriter
k
\family default
 is the name of either a 
\family typewriter
View
\family default
 or a 
\family typewriter
Group
\family default
 and that it exists in the environment.
\end_layout

\begin_layout Paragraph
bindCommand :: Ident -> [(Ident,Position)] -> State -> State
\end_layout

\begin_layout Standard
This function takes an 
\family typewriter
Ident
\family default
 
\family typewriter
k
\family default
 and a list of 
\family typewriter
Ident
\family default
s and 
\family typewriter
Position
\family default
s 
\family typewriter
l
\family default
 and maps 
\family typewriter
k
\family default
 to 
\family typewriter
l
\family default
 in a given 
\family typewriter
State
\family default
 and returns the new 
\family typewriter
State
\family default
.
\end_layout

\begin_layout Paragraph
addToState :: (State -> State) -> Context -> State
\end_layout

\begin_layout Standard

\family typewriter
addToState
\family default
 takes a function 
\family typewriter
f
\family default
 that takes a 
\family typewriter
State
\family default
 and returns a new 
\family typewriter
State
\family default
 and some 
\family typewriter
Context
\family default
 
\family typewriter
con
\family default
 and returns the result from applying 
\family typewriter
f
\family default
 to the 
\family typewriter
State
\family default
 within 
\family typewriter
con
\family default
.
\end_layout

\begin_layout Paragraph
bindDefinition :: Ident -> Definition -> Environment -> Environment
\end_layout

\begin_layout Standard
This functions binds an 
\family typewriter
Ident
\family default
 to a given 
\family typewriter
Definition
\family default
 into an given 
\family typewriter
Environment
\family default
 and returns the updated 
\family typewriter
Environment
\family default
.
\end_layout

\begin_layout Paragraph
addToEnvironment :: (Environment -> Environment) -> Context -> Context
\end_layout

\begin_layout Standard
This functions takes a function 
\family typewriter
f
\family default
, that does some computations on an 
\family typewriter
Environment
\family default
, a 
\family typewriter
Context
\family default
 
\family typewriter
con
\family default
 and returns the updated 
\family typewriter
Context
\family default
 from applying 
\family typewriter
f
\family default
 to the 
\family typewriter
Environment
\family default
 within 
\family typewriter
con
\family default
.
\end_layout

\begin_layout Paragraph
updateActiveViews :: [Ident] -> Context -> Context
\end_layout

\begin_layout Standard
This function takes a list of 
\family typewriter
Ident
\family default
s and updates these to be the list of active views in a given 
\family typewriter
Context
\family default
 and returns the updated 
\family typewriter
Context
\family default
.
\end_layout

\begin_layout Paragraph
placeShapeInActiveViews :: Definition -> Context -> Context
\end_layout

\begin_layout Standard
This function takes a 
\family typewriter
Definition
\family default
 
\family typewriter
def
\family default
 and a 
\family typewriter
Context
\family default
 and updates the 
\family typewriter
State
\family default
 within the given 
\family typewriter
Context
\family default
 by mapping the given shape and its position in all the currently active
 views.
 The function actually works as a wrapper around 
\family typewriter
placeShapeHelper
\family default
 that does the actual job, which has just been described.
\end_layout

\begin_layout Standard

\family typewriter
placeShapeInActiveViews
\family default
 assumes that the given 
\family typewriter
def
\family default
 is a shape definition, e.i.
 either rectangle or a circle.
\end_layout

\begin_layout Subsection
Animation functions
\end_layout

\begin_layout Paragraph
goToNextFrame :: Animation -> Animation
\end_layout

\begin_layout Standard
This function simply starts a new keyframe by appending an empty list to
 the back of the list of frames.
\end_layout

\begin_layout Paragraph
addInstructions :: [GpxInstr] -> Animation -> Animation
\end_layout

\begin_layout Standard
This function adds a given list of instructions to the current keyframe.
 That is by appending the instructions to the last frame found in the last
 of frames.
\end_layout

\begin_layout Paragraph
placeShapeInCurrentFrame :: Definition -> [ViewName] -> Animation -> Animation
\end_layout

\begin_layout Standard
This function generates instructions to draw a given shape in each view
 in a given list of views and add these instructions to the current keyframe.
 This function assumes that the given 
\family typewriter
Definition
\family default
 is either a rectangle or circle.
 This function is a wrapper around the helper function 
\family typewriter
placeShapeFrameHelper
\family default
 that does the described work.
\end_layout

\begin_layout Paragraph
addViewToAnimation :: (ViewName, Integer, Integer) -> Animation -> Animation
\end_layout

\begin_layout Standard

\family typewriter
addViewToAnimation
\family default
 adds a given view to the list of view definitions in a given 
\family typewriter
Animation
\family default
 and returns this updated 
\family typewriter
Animation
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix E Code
\end_layout

\begin_layout Subsection
at_server.erl
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/at_server/at_server.erl}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
at_extapi.erl
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/at_server/at_extapi.erl}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
test_at_server.erl
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/at_server/test_at_server.erl}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Gpx.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/Gpx.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SalsaAst.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/SalsaAst.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SalsaInterp.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/SalsaInterp.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
SalsaParser.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/SalsaParser.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Test_Interp.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/Test_Interp.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Test_Parser.hs
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/Test_Parser.hs}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
multi.salsa
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/test_files/multi.salsa}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
simple.salsa
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/test_files/simple.salsa}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
empty.salsa
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/test_files/empty.salsa}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
invalid.salsa
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstinputlisting[language=Haskell]{src/salsa/test_files/invalid.salsa}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
