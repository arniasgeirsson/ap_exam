#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage[a4paper]{geometry}
\usepackage{fancyhdr}

\pagestyle{fancy}

\fancyhead[LO,LE]{Left}
\fancyhead[CO,CE]{Center}
\fancyhead[RO,RE]{Right}

\usepackage{listings}
\usepackage{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=false,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
 % title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
AP Exam 2013
\end_layout

\begin_layout Author
Arni Asgeirsson lwf986
\end_layout

\begin_layout Date
Date?
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remove or comment on all used partial functions!!!!!!!!
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
- Introduction to this report (what is it about, what is the structure?,
 where are the tests?), the exam and the three questions.
\end_layout

\begin_layout Standard
- What files are being handed in?
\end_layout

\begin_layout Standard
- What is the structure of my src folder?
\end_layout

\begin_layout Standard
- That the handed in code also provides details of my implementations
\end_layout

\begin_layout Standard
- What do I feel is important to show/tell in this report?
\end_layout

\begin_layout Standard
+ How do i generally structure my assessments?
\end_layout

\begin_layout Standard
- Any general assumptions
\end_layout

\begin_layout Standard
- Any errors in the handed out code
\end_layout

\begin_layout Standard
- Where is all the code, and how much of it have I included?
\end_layout

\begin_layout Standard
- Any extra notes or comments
\end_layout

\begin_layout Standard
- What flags I have used when compiling my code.
\end_layout

\begin_layout Section
Question 1: The 
\noun on
Salsa
\noun default
 Language
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I have chosen ReadP beacuse it also allows me to check that if the grammar
 is ambiguous.
 How exactly?
\end_layout

\begin_layout Subsection
Fixing the grammar
\end_layout

\begin_layout Standard
The given grammar is ambiguous and this must be dealt with before proceeding
 with the actual parser.
 The given grammar is as follows and we shall call this G0.
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | Command ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command ’||’ Command
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Precedence and Associativity
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
OLEKS -2: The transformation of the grammar to handle precedence does not
 strictly speaking handle precedence.
 The problem is that the | is symmetric choice, so both options are valid,
 it is not that the seond option is _not_ considered if the first matches
 as you've expected.
 This is an important aspect in compilers, but not so much in AP.
\end_layout

\begin_layout Plain Layout
OLEKS -2: On the contrary, you should've mentioned _why_ you chose to use
 <++ instead of the fully symmetric choice operator +++ in ReadP.
 The reason is that you wanted precedence.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- What is what?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is assumed that the four operators +, -, @ and || all are left-associative.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Remove @ ? Wait for discu..
 answer.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- What has precedence?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I assume that + and - have the same precedence, and as the assignment text
 specifies then @ has higher precedence than ||, meaning that if we have
 the following pseudo input 
\begin_inset Quotes eld
\end_inset

cmd || cmd @ Vident
\begin_inset Quotes erd
\end_inset

 then this corresponds to the input 
\begin_inset Quotes eld
\end_inset

cmd || ( cmd @ Vident )
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
I further assume that .
 has higher precedence than + and - meaning that 
\begin_inset Quotes eld
\end_inset

r .
 x + c .
 y
\begin_inset Quotes erd
\end_inset

 is the same as 
\begin_inset Quotes eld
\end_inset

(r .
 x) + (c .
 y)
\begin_inset Quotes erd
\end_inset

.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Needed to assume this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Do we need to fix it here in the grammar? Is that even possible? No, but
 we could help it, although the case is very small and might as well fix
 it by using the operators of ReadP ?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The associativity is already in place and the precedence of +, - and .
 is also already supported by the current grammar.
 What is missing is that @ and || have the correct precedence.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
How do we then ensure this?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To do so we followed a simple algorithm:
\end_layout

\begin_layout LyX-Code
A ::= A a1 A
\end_layout

\begin_layout LyX-Code
    | A a2 A
\end_layout

\begin_layout LyX-Code
    | a3 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= A a1 B
\end_layout

\begin_layout LyX-Code
    | B .
\end_layout

\begin_layout LyX-Code
B ::= B a2 C
\end_layout

\begin_layout LyX-Code
    | C .
\end_layout

\begin_layout LyX-Code
C ::= a3 .
\end_layout

\begin_layout Standard
where a1 & a2 are terminals, a3 is something 'else'
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv mere prof
\end_layout

\end_inset

 and A,B,C are non-terminals.
 Now a2 will have higher precedence than a1.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Reference G0 somewhere.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following is the resulting grammar and we shall call this G1
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom
\end_layout

\begin_layout LyX-Code
    | DefCom DefComs .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent
\end_layout

\begin_layout LyX-Code
    | VIdent VIdents .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent
\end_layout

\begin_layout LyX-Code
    | SIdent SIdents .
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | Expr ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ ’y’
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Left factorization
\end_layout

\begin_layout Standard
We can see that G1 contains the case of left factorization problem.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rephrase!!
\end_layout

\end_inset

 We therefore start by fixing this by doing left factorization on G1.
\end_layout

\begin_layout Standard
I have summarized how I do left factorization in the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= B a1
\end_layout

\begin_layout LyX-Code
    | B a2.
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= B A' .
\end_layout

\begin_layout LyX-Code
A'::= a1
\end_layout

\begin_layout LyX-Code
    | a2 .
\begin_inset Note Note
status open

\begin_layout Plain Layout
note that if any of the prev a1-an is nothing, then A' should also have
 epsilon e clause 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where A, As' and B are non-terminals and a1 & a2 are something else.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Skriv det ordenligt!!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting grammar is as follows and this shall be called G2.
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command ’||’ Command2
\end_layout

\begin_layout LyX-Code
    | Command2 .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command2 ’@’ VIdent
\end_layout

\begin_layout LyX-Code
    | Command3 .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim
\end_layout

\begin_layout LyX-Code
    | Expr Rest2 .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent ’.’ Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’x’
\end_layout

\begin_layout LyX-Code
    | ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Subsubsection
Left recursion
\end_layout

\begin_layout Standard
When we look at G2 we can quickly see that there is a few cases of direct
 left-recursion.
 The next is I take is therefore to remove left-recursion from our current
 grammar G2, with the following algorithm:
\end_layout

\begin_layout LyX-Code
A ::= A a1
\end_layout

\begin_layout LyX-Code
    | b1 .
\end_layout

\begin_layout LyX-Code
->
\end_layout

\begin_layout LyX-Code
A ::= b1 A' .
\end_layout

\begin_layout LyX-Code
A'::= a1 A'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout Standard
where A and A' are non-terminals and a1 & b1 are 
\begin_inset Note Note
status open

\begin_layout Plain Layout
what?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
When applying the procedure/algorithm on G2 we get the grammar G3 which
 is shown below:
\end_layout

\begin_layout LyX-Code
Program ::= DefComs .
\end_layout

\begin_layout LyX-Code
DefComs ::= DefCom DefComs' .
\end_layout

\begin_layout LyX-Code
DefComs' ::= DefComs
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
DefCom ::= Command
\end_layout

\begin_layout LyX-Code
    | Definition .
\end_layout

\begin_layout LyX-Code
Definition ::= ’viewdef’ VIdent Expr Expr
\end_layout

\begin_layout LyX-Code
    | ’rectangle’ SIdent Expr Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’circle’ SIdent Expr Expr Expr Colour
\end_layout

\begin_layout LyX-Code
    | ’view’ VIdent
\end_layout

\begin_layout LyX-Code
    | ’group’ VIdent ’[’ VIdents ’]’ .
\end_layout

\begin_layout LyX-Code
Command ::= Command2 Command' .
\end_layout

\begin_layout LyX-Code
Command' ::= ’||’ Command2 Command'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command2 ::= Command3 Command2' .
\end_layout

\begin_layout LyX-Code
Command2' ::= ’@’ VIdent Command2'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Command3 ::= SIdents ’->’ Pos
\end_layout

\begin_layout LyX-Code
    | ’{’ Command ’}’ .
\end_layout

\begin_layout LyX-Code
VIdents ::= VIdent VIdents' .
\end_layout

\begin_layout LyX-Code
VIdents' ::= VIdents
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
SIdents ::= SIdent SIdents' .
\end_layout

\begin_layout LyX-Code
SIdents' ::= SIdents
\end_layout

\begin_layout LyX-Code
    | e.
\end_layout

\begin_layout LyX-Code
Pos ::= ’(’ Expr ’,’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | ’+’ ’(’ Expr ’,’ Expr ’)’ .
\end_layout

\begin_layout LyX-Code
Expr ::= Prim Expr' .
\end_layout

\begin_layout LyX-Code
Expr' ::= Rest2 Expr'
\end_layout

\begin_layout LyX-Code
    | e .
\end_layout

\begin_layout LyX-Code
Op :: = ’+’ Prim
\end_layout

\begin_layout LyX-Code
    | ’-’ Prim .
\end_layout

\begin_layout LyX-Code
Prim ::= integer
\end_layout

\begin_layout LyX-Code
    | ’(’ Expr ’)’
\end_layout

\begin_layout LyX-Code
    | SIdent Rest3 .
\end_layout

\begin_layout LyX-Code
Proj ::= ’.’ ’x’
\end_layout

\begin_layout LyX-Code
    | ’.’ ’y’ .
\end_layout

\begin_layout LyX-Code
Colour ::= ’blue’ | ’plum’ | ’red’ | ’green’ | ’orange’ .
\end_layout

\begin_layout Standard
In the rest of the report G3 will be the referred grammar unless something
 else is specified.
\end_layout

\begin_layout Subsection
Assumptions on the grammar
\end_layout

\begin_layout Standard
Some of the non-terminals in the grammar are not specified in the grammar,
 and only partly described in the assignment text.
 I will therefore list my assumptions and the definitions that I use in
 my implementation.
\end_layout

\begin_layout Subsubsection
Case sensitivity
\end_layout

\begin_layout Standard
I assume that Samba is case sensitive.
 (This should be given from all definition of 
\emph on
VIdent
\emph default
 and 
\emph on
SIdent
\emph default
)
\end_layout

\begin_layout Subsubsection
integer
\end_layout

\begin_layout Standard
Is a non-negative integer number and can therefore be written with the following
 regular expression: 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[0-9]^{+}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
VIdent
\end_layout

\begin_layout Standard
As the assignment text specifies then 
\emph on
VIdent
\emph default
 is a nonempty sequence of letters, digits and underscore, which starts
 with a uppercase letter and can therefore be written with the following
 regular expression:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[A-Z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
SIdent
\end_layout

\begin_layout Standard

\emph on
SIdent
\emph default
 is the same as a 
\emph on
VIdent
\emph default
 except it cannot be one of the reserved words, described below, and has
 to start with a lowercase letter, which can be described as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
[a-z]^{+}[A-Za-z0-9\_]^{*}
\]

\end_inset


\end_layout

\begin_layout Subsubsection
White spaces
\end_layout

\begin_layout Standard
Whitespaces are what most would expect, spaces, any tabs, newlines and unicode
 spaces
\begin_inset Note Note
status open

\begin_layout Plain Layout
What is unicode spaces, do they belong here?
\end_layout

\end_inset

.
 As I am using ReadP I will let the the function skipSpaces
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Link to documentation
\end_layout

\end_inset

 define the exact representation of white spaces.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The reserved words, color names, 
\emph on
VIdent
\emph default
, and 
\emph on
SIdent
\emph default
 are separated by at least one white space of any kind.
 Symbolic tokens are separated by 0 or more white spaces and so are symbolic
 tokens and alpha-numeric tokens from each other.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Rephrase?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Reserved Words
\end_layout

\begin_layout Standard
The reserved words are: 'viewdef', 'rectangle', 'circle', 'group' and 'view'.
\end_layout

\begin_layout Subsubsection
Color Names
\end_layout

\begin_layout Standard
The names of the color are also considered to be reserved words and are
 the following: 'blue', 'plum', 'red', 'green' and 'orange'.
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Where can I find the code? both files and appendixes?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the remaining warnings and hints.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is there anything I could have done differently?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Paragraph
parseString :: String -> Either Error Program
\end_layout

\begin_layout Standard
This function is rather straight forward as it simply parses a given input
 string to a program or an error if the input string is invalid.
\end_layout

\begin_layout Paragraph
parseFile :: FilePath -> IO (Either Error Program)
\end_layout

\begin_layout Standard
This function extends the functionality of 
\family typewriter
parseString
\family default
 by reading the input string from a given file path.
\end_layout

\begin_layout Subsubsection
DataTypes
\end_layout

\begin_layout Paragraph
Error
\end_layout

\begin_layout Standard
I have defined the Error type to be of the following
\end_layout

\begin_layout LyX-Code
data Error = NoParsePossible String
\end_layout

\begin_layout LyX-Code
           | AmbiguousGrammar [(Program, String)]
\end_layout

\begin_layout LyX-Code
           | UnexpectedRemainder Program String
\end_layout

\begin_layout Standard
Here we can see that a invalid salsa program can either return that it cannot
 be parsed to anything at all, a parsed program and some remainder or multiply
 parsed programs showing that the grammar is ambiguous, or at least that
 the implementation of the grammar is.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why did I choose these three? And what do they carry?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Parser functions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the use of +++ and <++
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
parse
\end_layout

\begin_layout Standard
This function takes a parser 
\emph on
p
\emph default
 of type 
\family typewriter
ReadP Program 
\family default
and a string 
\emph on
s
\emph default
 and parses 
\emph on
s
\emph default
 with 
\emph on
p
\emph default
 and and returns the parsed program or the appropriate error if the input
 did not adhere to the grammar.
\end_layout

\begin_layout Paragraph
runParser
\end_layout

\begin_layout Standard
This parser is a wrapper for the 
\family typewriter
pProgram
\family default
 parser and simply makes sure to skip spaces both before and after parsing
 a program and also makes sure that we are at the end of the input after
 parsing a program.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Doesn't this remove the need of the 'UnexpectedRemainder' error?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pProgram
\end_layout

\begin_layout Standard
Parses a program by trying to parse a list of definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs
\end_layout

\begin_layout Standard
Parses a single definition or command and then tries to parse a list of
 definitions and or commands.
\end_layout

\begin_layout Paragraph
pDefComs'
\end_layout

\begin_layout Standard
Parses either a list of commands and or definitions, nothing or a symmetric
 choice of both.
\end_layout

\begin_layout Paragraph
pDefCom
\end_layout

\begin_layout Standard
Parses either a command or a definition.
\end_layout

\begin_layout Paragraph
pDefinition
\end_layout

\begin_layout Standard
Parses a definition by either parsing a view definition, rectangle, circle,
 view or a group definition.
 I decided to split 
\family typewriter
pDefinition
\family default
 into five individual parsers 
\family typewriter
hViewdef
\family default
, 
\family typewriter
hRectangle
\family default
, 
\family typewriter
hCircle
\family default
, 
\family typewriter
hView
\family default
 and 
\family typewriter
hGroup
\family default
 to make it more readable and intuitive to understand what is happening.
\end_layout

\begin_layout Paragraph
pCommand
\end_layout

\begin_layout Standard
Is the top-level parser for parsing a command by using the 
\family typewriter
pCommand'
\family default
, 
\family typewriter
pCommand2
\family default
, 
\family typewriter
pCommand2'
\family default
 and 
\family typewriter
pCommand3
\family default
 parsers.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
This parses a command2 type which is either a move, bracketed or a series
 of '@' commands and then parses a command' with the previous command as
 incoming value.
\end_layout

\begin_layout Paragraph
pCommand'
\end_layout

\begin_layout Standard
Either parses a '||' command followed by another command' parsing or nothing.
\end_layout

\begin_layout Paragraph
pCommand2
\end_layout

\begin_layout Standard
First parses a command3 then parses a command2' with the command3 as incoming
 value.
\end_layout

\begin_layout Paragraph
pCommand2'
\end_layout

\begin_layout Standard
Either parses a '@' command followed by another command2' parse or nothing.
\end_layout

\begin_layout Paragraph
pCommand3
\end_layout

\begin_layout Standard
Parses either a move command or a command wrapped in a set of curly-brackets.
\end_layout

\begin_layout Paragraph
pVIdents
\end_layout

\begin_layout Standard
Parses a single vident followed by possible a list of vidents.
\end_layout

\begin_layout Paragraph
pVIdents'
\end_layout

\begin_layout Standard
Parses a list of vidents or nothing.
\end_layout

\begin_layout Paragraph
pSIdents
\end_layout

\begin_layout Standard
Parses a single sident followed by possible a list of sidents.
\end_layout

\begin_layout Paragraph
pSIdents'
\end_layout

\begin_layout Standard
Parses a list of sidents or nothing.
\end_layout

\begin_layout Paragraph
pPos
\end_layout

\begin_layout Standard
Parses a position of either the 
\family typewriter
Abs
\family default
 or 
\family typewriter
Rel
\family default
 type.
\end_layout

\begin_layout Paragraph
pExpr
\end_layout

\begin_layout Standard
Parses an expression by parsing a prim and then using that as incoming value
 to call 
\family typewriter
pExpr'
\family default
.
\end_layout

\begin_layout Paragraph
pExpr'
\end_layout

\begin_layout Standard
Starts by parsing either a plus or minus expression 
\emph on
e
\emph default
 with the incoming value and then another expr' with 
\emph on
e
\emph default
, otherwise it parses nothing by just returning the incoming value.
\end_layout

\begin_layout Paragraph
pOp
\end_layout

\begin_layout Standard
Takes an incoming expression and either parses a plus or a minus, then the
 next prim and returns this.
\end_layout

\begin_layout Paragraph
pPrim
\end_layout

\begin_layout Standard
Parses a either an integer, an expression contained within a set of parenthesis
 or either an 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Rephrase!!
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
pProj
\end_layout

\begin_layout Standard
This parser takes an ident as an incoming value and parses either an 'x'
 or a 'y' and then returns the appropriate Expression of type 
\family typewriter
Xproj
\family default
 or 
\family typewriter
Yproj
\family default
.
\end_layout

\begin_layout Paragraph
pColour
\end_layout

\begin_layout Standard
Parses one of the defined colours.
\end_layout

\begin_layout Paragraph
pVIdent
\end_layout

\begin_layout Standard
Simply parses a vident and skips all white spaces both before and after
 the word.
\end_layout

\begin_layout Paragraph
pSIdent
\end_layout

\begin_layout Standard
Parses a sident and as same as the above also skips all white spaces both
 before and after the word.
 If the parsed word is one of the reserved words or one of the colour names
 then it fails, otherwise it returns the parsed word.
\end_layout

\begin_layout Paragraph
pInteger
\end_layout

\begin_layout Standard
Parses an integer and skips all white spaces both before and after the integer.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Note on the use of read?
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
bracks
\end_layout

\begin_layout Standard
Takes in two a characters 
\emph on
a
\emph default
 and 
\emph on
b
\emph default
 and a parser 
\emph on
p
\emph default
, and parses the 
\emph on
a
\emph default
 and 
\emph on
b
\emph default
 around the parsing of 
\emph on
p
\emph default
 with the use of 
\family typewriter
charT
\family default
 and returns the result from 
\emph on
p
\emph default
.
\end_layout

\begin_layout Paragraph
stringT
\end_layout

\begin_layout Standard
Parses a given string 
\emph on
s
\emph default
 and skips white spaces around 
\emph on
s.
\end_layout

\begin_layout Paragraph
charT
\end_layout

\begin_layout Standard
Parses a given character 
\emph on
a
\emph default
 and skips white spaces around 
\emph on
a.
\end_layout

\begin_layout Subsection
Tests?
\end_layout

\begin_layout Section
Question 2: Interpreting 
\noun on
Salsa
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Any assumptions
\end_layout

\begin_layout Standard
- How the coordinate system is defined, see page 8 - top.
\end_layout

\begin_layout Standard
- The position of the different shapes, i.e.
 their anchor points/pivot points.
\end_layout

\begin_layout Standard
- 
\begin_inset Quotes eld
\end_inset

All of these can be checked statically prior to executing the Salsa program,
 hence you don’t have to worry about proper error handling in this question.
 If you encounter an error, you should halt the interpreter by calling the
 built-in Haskell function error.
 Writing the static check, as a separate pass over the abstract syntax tree,
 is not part of the exam.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Specify what should happen with 
\begin_inset Quotes eld
\end_inset

b -> (0,0) @ A @ B
\begin_inset Quotes erd
\end_inset

: I was unable to deduce from the assignment text what exactly should happen
 in the case of ..
 I assume that ..
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Comment on the remaining warnings and hints.
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
The Monad(s)
\end_layout

\begin_layout Subsubsection
Interface functions
\end_layout

\begin_layout Subsubsection
Implementation functions
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Subsubsection
Graphics engine functions?
\end_layout

\begin_layout Subsection
Tests?
\end_layout

\begin_layout Section
Question 3: Atomic Transaction Server in Erlang
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Initial Comments/Introduction to the question:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
I decided to use gen_server,
\begin_inset Note Note
status open

\begin_layout Plain Layout
 why? What I could else have done/used?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This also explains all the 'comments' in the file.
\end_layout

\begin_layout Subsection
Any assumptions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
- Define 'atomic transaction'
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
%% COM I always assume that AT is a valid at_server process id, this is
 never %% checked and if called with invalid value may result in unexpected
 error, behaviour or %% and endless waiting for a never responding process.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
%% COM I make no assumptions on the input State
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
General structure of the server, transactions, states and messages being
 passed (show some images?)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
COM One could force the transactions to only receive/listen to messages
 sent from the master.
 But really needed? Out of scope?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before proceeding to my actual implementation then I want try and describe
 the overall structure of my atomic transaction server and its managed transacti
ons and requests.
\end_layout

\begin_layout Subsubsection
Who talks to who?
\end_layout

\begin_layout Subsubsection
What is a process and what is not?
\end_layout

\begin_layout Subsubsection
The status of each transaction
\end_layout

\begin_layout Subsubsection
The pool (list of transactions)
\end_layout

\begin_layout Subsubsection
The answer to the problem stated at page 13 - top.
\end_layout

\begin_layout Subsection
The Code
\end_layout

\begin_layout Subsubsection
The Server API / Interface functions
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
%% COM prove when something is blocking or non-blocking
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
start(State)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Use start or start_link?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This function creates a new atomic transaction server (ATS) and returns
 the message 
\family typewriter
{ok,Pid}
\family default
 where 
\family typewriter
Pid
\family default
 is the process id of the newly created ATS.
\end_layout

\begin_layout Standard
Several ATSs can be started using 
\family typewriter
start/1
\family default
 and run indenpendently.
\end_layout

\begin_layout Standard
Note that I don't make any assumptions on the given 
\family typewriter
State
\family default
 value, as this should be allowed to be anything and is defined through
 the functions that act upon it.
\end_layout

\begin_layout Paragraph
stop(AT)
\end_layout

\begin_layout Standard

\family typewriter
stop/1
\family default
 makes a synchronous call to the ATS with the given process id 
\family typewriter
AT
\family default
, and orders it to shutdown and return the current state.
 
\family typewriter
stop/1
\family default
 will not return until all processes handled by the ATS, including it self,
 has been shutdown, allowing the caller to be certain that when 
\family typewriter
stop/1
\family default
 returns everything is cleaned up.
 Instead of making the call asynchronous and forcing the caller to be in
 doubt and ultimately the need to wait some random amount of time before
 the processes are shutdown, or have some unexpected behavior.
\end_layout

\begin_layout Paragraph
doquery(AT, Fun) // must block
\end_layout

\begin_layout Standard
This function performs the given function 
\family typewriter
Fun
\family default
 on the current state of the ATS with pid 
\family typewriter
AT
\family default
 and returns the result in the form 
\family typewriter
{ok, Result}
\family default
.
 
\end_layout

\begin_layout Standard
If 
\family typewriter
Fun
\family default
 fails 
\family typewriter
error
\family default
 is returned.
 
\family typewriter
doquery/2
\family default
 does not update the state of the server in any way.
\end_layout

\begin_layout Paragraph
begin_t(AT)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
The call to the server to create a new transaction is sent synchronous meaning
 that the transaction is ready to use.
 But is it really that? Is start/3 really sure that it is started when it
 returns?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here a new transaction is initialized and keeps a copy of the current state
 of the given ATS and a unique reference to the transaction is returned.
 Updates and queries can then be performed on the new transaction, although
 it belongs to the ATS that it was created within, and can therefore not
 be used to update the state of some other ATS.
\end_layout

\begin_layout Standard
For the unique reference then 
\family typewriter
make_ref()
\family default
 is used as it guarantees that approximately the first 
\begin_inset Formula $2^{82}$
\end_inset

 created references are unique
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
http://www.erlang.org/doc/man/erlang.html#make_ref-0
\end_layout

\end_inset

.
 One could just return the process id of the transaction, but this makes
 it easier for the user to send unwanted messages to the transactions, stop
 it or in any other way mess it up.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Is the process id as unique as make_ref/0 ?
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
query_t(AT, Ref, Fun) // must block
\end_layout

\begin_layout Standard

\family typewriter
query/3
\family default
 makes a synchronous call to the specified ATS which in turn makes a synchronous
 call to the specified transaction 
\family typewriter
Ref
\family default
 and performs 
\family typewriter
Fun
\family default
 on the state of 
\family typewriter
Ref
\family default
 and returns the result to the original caller.
 The state of 
\family typewriter
Ref
\family default
 is not updated in any way.
\end_layout

\begin_layout Standard
If the function fails in any way, then the transaction is aborted and 
\family typewriter
aborted
\family default
 is returned to the caller.
\end_layout

\begin_layout Standard
If 
\family typewriter
Ref
\family default
 is an already aborted transaction or non-existing transaction then 
\family typewriter
aborted
\family default
 is returned.
\end_layout

\begin_layout Paragraph
update_t(AT, Ref, Fun) // must not block
\end_layout

\begin_layout Standard

\family typewriter
update_t/3
\family default
 makes an asynchronous call to the ATS and further on to the specified transacti
on 
\family typewriter
Ref
\family default
 to update its state with the result from calling 
\family typewriter
Fun
\family default
 with its current state.
 As the call is asynchronous update_t/3 always returns immediately with
 
\family typewriter
ok
\family default
 and the caller cannot be sure wether it was a successful update or not.
 If the function fails then the transaction gets aborted and any future
 query or commit calls to that transaction 
\family typewriter
Ref
\family default
 will forever return 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Standard
If the transaction was already aborted or the given 
\family typewriter
Ref
\family default
 does not exist then the update call is ignored.
\end_layout

\begin_layout Paragraph
commit_t(AT, Ref)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
%% COM why sync and not async, since ass.
 text doesnt say anything 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To commit a transaction 
\family typewriter
commit_t/2
\family default
 is used.
 It takes a process id 
\family typewriter
AT
\family default
 of an ATS, a transaction reference 
\family typewriter
Ref
\family default
 and tries to commit that transaction, i.e.
 update the state of the ATS with the state of 
\family typewriter
Ref
\family default
.
 If the given transaction has been aborted or does simply not exist, then
 
\family typewriter
aborted
\family default
 is returned.
\end_layout

\begin_layout Standard
If the commit was successful then the state of the ATS is updated to be
 the current state of the given transaction, followed by all current transaction
s being aborted, including the one that was committed.
 Meaning that with every successful commit every transaction is aborted,
 and all future action on any previous transaction will return aborted,
 or ignore if the action is 
\family typewriter
update_t/3
\family default
, and the ATS is at a 'clean' state
\begin_inset Note Note
status open

\begin_layout Plain Layout
What do I mean by this, clean state?
\end_layout

\end_inset

.
 The assignment text specifies several times that all the 
\emph on
other
\emph default
 transactions must aborted when doing a successful commit, but it also states
 that committing an already successfully committed transaction must return
 
\family typewriter
aborted
\family default
, inclining that this transaction has been aborted, and therefore must be
 aborted after it has been committed.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

The assignment text does not state wether this function must block or not,
 as it has done with some of the previous ones.
 I have chosen to make it a synchronous call to the ATS to let it be possible
 to return the proper return value to the caller, and to lock the master
 while he is committing to try and disallow any outside interference.
\end_layout

\begin_layout Paragraph
get_pids(AT)
\end_layout

\begin_layout Standard

\family typewriter
get_pids/1
\family default
 is an interface function that I have added for the sake of testing, it
 makes a synchronous call to a given ATS and returns a list of process id
 over all the living processes that the given ATS is managing, including
 it self.
\end_layout

\begin_layout Subsubsection
Extended API
\end_layout

\begin_layout Standard
All the four functions of the extended API are blocking functions.
\end_layout

\begin_layout Paragraph
abort(AT, Ref)
\end_layout

\begin_layout Standard
This function forces a transaction 
\family typewriter
Ref
\family default
 to be aborted.
 I have implemented this functionality by querying the transaction with
 a function that always raises an error, as shown below.
\end_layout

\begin_layout LyX-Code
abort(AT, Ref) ->
\end_layout

\begin_layout LyX-Code
    at_server:query_t(AT,Ref,fun(_) -> error(force_abort) end).
\end_layout

\begin_layout Standard
This forces the query function to fail and cause the transaction to be aborted.
\end_layout

\begin_layout Standard
By using 
\family typewriter
query_t/3
\family default
 I also cause the 
\family typewriter
abort/2
\family default
 function to block, i.e.
 by making a synchronous call to the server.
 I could have used 
\family typewriter
update_t/3
\family default
 with the same error-raising-function, and allow 
\family typewriter
abort/2
\family default
 to return immediately, this would though open up for the possibility that
 we could try and query, update or even commit the transaction successfully
 due to the nature of the message order, before our error-function is run
 and aborts the transaction.
 By using 
\family typewriter
query_t/3
\family default
 I can guarantee the caller that when 
\family typewriter
abort/2
\family default
 returns the transaction is indeed aborted.
\end_layout

\begin_layout Standard
I have defined the return value of 
\family typewriter
abort/2
\family default
 to be the return value of 
\family typewriter
query_t/3
\family default
, which implies that 
\family typewriter
abort/2
\family default
 can only return 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Paragraph
tryUpdate(AT, Fun)
\end_layout

\begin_layout Standard
As the name implies; 
\family typewriter
tryUpdate/2
\family default
 tries to update a specified ATS with the given function 
\family typewriter
Fun
\family default
, if the 
\family typewriter
Fun
\family default
 fails then error is returned but if a transaction is successfully updated
 with 
\family typewriter
Fun
\family default
 then the return value of 
\family typewriter
tryUpdate/2
\family default
 is the return value of commit attempt.
\end_layout

\begin_layout Standard
To allow 
\family typewriter
tryUpdate/2
\family default
 to return error if 
\family typewriter
Fun
\family default
 fails I start by querying the spawned transaction and checking the result.
 Then to avoid performing 
\family typewriter
Fun
\family default
 twice, as it may be expensive, the provided update function to the transaction
 is simply just a function that does not care about the previous state and
 merely returns the result from the query.
 Although this does add a slight unnecessary overhead of transporting the
 result from the query back and forth, but allows us to return 
\family typewriter
error
\family default
 when 
\family typewriter
Fun
\family default
 fails.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The tryUpdate/2 function starts by beginning a transaction within AT, then
 does the query and if it succeeds then the transaction is updated and at
 last committed.
\end_layout

\begin_layout Paragraph
ensureUpdate(AT, Fun)
\end_layout

\begin_layout Standard

\family typewriter
ensureUpdate/2
\family default
 takes a pid of an ATS and a function 
\family typewriter
Fun
\family default
 and promises to update the ATS with the function 
\family typewriter
Fun
\family default
 and return 
\family typewriter
ok
\family default
, except if 
\family typewriter
Fun
\family default
 fails, then 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
I felt that the assignment text was not clear of which state 
\family typewriter
ensureUpdate/2
\family default
 should update.
 As one can easily imagine the case of someone else making a commit before
 
\family typewriter
ensureUpdate/2
\family default
 is able to actual update a transaction and performing a commit, forcing
 the function to try again.
 But which state should 
\family typewriter
ensureUpdate/2
\family default
 now update, the new state of the ATS or the initial state that the AST
 had when 
\family typewriter
ensureUpdate/2
\family default
 was first called? I decided to go with the second case, as I felt that
 this would make most sense
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why?
\end_layout

\end_inset

.
 This approach would mean that we have to rollback those commits that snuck
 in while we were trying to update the state of the ATS, but this also allows
 us to only compute the function 
\family typewriter
Fun
\family default
 one time instead of recalculating it whenever we have to try again, because
 someone else made a commit before us, and if 
\family typewriter
Fun
\family default
 is expensive; this could go on for a very long time
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
%% COM As while we try to update the state of AT someone else could do it,
 %% meaning that either we have to do a rollback of that commit, lying to
 the other %% client, thinking that he got a commit through, even though
 we are just going to %% neglect that, as we MUST ensure our update of the
 state data, unless the Fun %% raises some error, and no rollback will occour.
 %% Otherwise we could check that if the state of AT has changed before
 we commit, %% but after we have updated, but this could happen forever,
 leading to that we %% starve ourselves.
 And what if the third time around threw an error, and it was %% just a
 matter of chance (underlying process scheduling, cpu-bussiness, randomness,
 and-so-on) %% if we could have gotten the second update through.
 Blaaw, lots of trouble, I will stick %% to the rollback, even though this
 could mean that we rollback possible many commits.
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family typewriter
ensureUpdate/2
\family default
 start by beginning a new transaction 
\family typewriter
T
\family default
 and then query 
\family typewriter
T
\family default
 with 
\family typewriter
Fun
\family default
, if the result is aborted then I conclude that 
\family typewriter
Fun
\family default
 failed and return 
\family typewriter
error
\family default
.
 If some new state 
\family typewriter
S
\family default
 was returned start a loop function 
\family typewriter
ensureLoop/2
\family default
 that will keep trying to update the state of the ATS to be 
\family typewriter
S
\family default
, until it succeeds.
 This ensures that it was the initial state of the ATS that is updated and
 not the in-between committed states.
\end_layout

\begin_layout Paragraph
choiceUpdate(AT, Fun, Val_list)
\end_layout

\begin_layout Standard

\family typewriter
choiceUpdate/3
\family default
 takes, as always, a pid for an ATS, a function 
\family typewriter
Fun(State,E)
\family default
 and a list of element 
\family typewriter
Val_list
\family default
, where 
\family typewriter
State
\family default
 is the state of the ATS and 
\family typewriter
E
\family default
 is an element from 
\family typewriter
Val_list
\family default
.
 
\family typewriter
choiceUpdate/3
\family default
 then tries for each element in 
\family typewriter
Val_list
\family default
 to update the state of the ATS with 
\family typewriter
Fun
\family default
 in parallel.
 The first one to finish its update function is also the one that 
\family typewriter
choiceUpdate/3
\family default
 tries to commit and the return value is then the return value from that
 commit.
 If all update functions fail then 
\family typewriter
error
\family default
 is returned.
\end_layout

\begin_layout Standard
It is assumed that 
\family typewriter
Val_list
\family default
 is indeed a list.
\end_layout

\begin_layout Standard
The function starts by beginning an amount of transactions equal to the
 number of elements in 
\family typewriter
Val_list
\family default
.
 Then foreach of these transactions they are asked to update their state
 with 
\family typewriter
Fun
\family default
 and the respective element 
\family typewriter
E
\family default
.
 The update function has been altered to include a try and catch around
 
\family typewriter
Fun
\family default
, which makes sure to send the correct message back to us.
 We then enter a loop function called 
\family typewriter
choiceLoop/2
\family default
 where we wait for the first transaction to succeed its update function
 or that all transactions failed to update their state.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
An important and somewhat trivial aspect of 
\family typewriter
choiceUpdate/3
\family default
 is that all the transactions must have been begun before any one of them
 starts updating otherwise one transaction might have finished its update
 function before another had even been created.
 Therefore all are begun before any one is asked to update, to ensure a
 greater fairness to each transaction.
 Of course running through the list and asking each to update one by one,
 also favors the first transactions in the list, but this is how far the
 fairness is possible to stretch in this case.
\end_layout

\begin_layout Standard
xHow can I ensure that it is the first one that gets through
\end_layout

\begin_layout Standard
- Do I need to talk about the communication again?
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Parallelism is achieved by utilizing that 
\family typewriter
update_t/3
\family default
 is called asynchronously, and that each transaction runs in its own process.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The assignment text specifies that 
\family typewriter
choiceUpdate/3
\family default
 must return the value of the commit of the first transaction to update
 successfully, but this is not possible if none update succeeds.
 Instead of letting the function hang and wait forever for some transaction
 to update successfully, I have added the try-catch inside the update function
 to be able to let 
\family typewriter
choiceUpdate/3
\family default
 know if some transaction was aborted and ultimately allowing it to know
 if all fail and then return 
\family typewriter
error
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
There is also the slight change that someone else makes a commit before
 any of our transactions gets through, 
\family typewriter
choiceUpdate/3
\family default
 will still could the commit with the first successful transaction to update,
 if any, but as implied the return value would then be 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Subsubsection
Callback functions
\end_layout

\begin_layout Standard
The 
\family typewriter
format_status/2
\family default
 function is not used, and as it is an optional callback function I have
 not implemented it.
\end_layout

\begin_layout Standard
Some of the callback functions are rather big and mixed with callbacks to
 both the ATS, transactions and both, therefore when describing some of
 these I will divide them into the three cases ATS, Transaction and Both
 equal to their separation in the actual file 
\emph on
at_server.erl
\emph default
, to try and make it more readable.
\end_layout

\begin_layout Paragraph
init(Args)
\end_layout

\begin_layout Standard
The 
\family typewriter
init/1
\family default
 function is called by the 
\emph on
gen_server
\emph default
 when an atomic server or a transaction must be spawned.
 It is used to set the init state of the created server.
\end_layout

\begin_layout Standard
When an ATS is being created from the 
\family typewriter
start/1
\family default
 interface function, then I have wrapped the initial given 
\family typewriter
State
\family default
 in a tuple with the atom 
\family typewriter
server
\family default
 as the first element to know this in the init function and set the init
 pool size to be an empty list.
\end_layout

\begin_layout Standard
If a new transaction is being created by the ATS then the atom 
\family typewriter
transaction
\family default
 is passed along in the same fashion as 
\family typewriter
server
\family default
 and the initial status is set to 
\family typewriter
ready
\family default
.
\end_layout

\begin_layout Paragraph
handle_call/3
\end_layout

\begin_layout Standard

\family typewriter
handle_call/3
\family default
 is called by the 
\emph on
gen_server
\emph default
 when a synchronous request is send to the server.
 Here I have split the description into the three parts.
\end_layout

\begin_layout Subparagraph
ATS
\end_layout

\begin_layout Standard
If the 
\family typewriter
stop_at_server
\family default
 request is send to an ATS then it propagates the stop request to all the
 transactions that it manages, before terminating it self with the reason
 
\family typewriter
normal
\family default
, and the reply 
\family typewriter
{ok,State}
\family default
 where 
\family typewriter
State
\family default
 is the current state of the ATS.
\end_layout

\begin_layout Standard
When a 
\family typewriter
{doquery_t, {Ref, Fun}}
\family default
 request is received then the ATS looks 
\family typewriter
Ref
\family default
 up in its table of transactions, if it exist and has the status 
\family typewriter
ready
\family default
 then we try to query the transaction with the given 
\family typewriter
Fun
\family default
, if it returns 
\family typewriter
error
\family default
 then we remove it from our pool of transactions or mark it state to be
 
\family typewriter
aborted
\family default
 and reply 
\family typewriter
aborted
\family default
, if not then we return the result.
 If the look up failed then we also reply 
\family typewriter
aborted
\family default
.
\end_layout

\begin_layout Standard
If an ATS received a 
\family typewriter
begin_t
\family default
 query then it creates a unique reference and then tries to find an idle
 transaction within its pool, which it then initializes to be an fresh and
 ready transaction to be used.
 If no transaction was found, then a new one is started/spawned and the
 ATS adds it to its pool, at last the unique reference is then replied to
 the caller.
\end_layout

\begin_layout Standard
When 
\family typewriter
{commit_t, Ref}
\family default
 is received then the ATS starts by look up in its pool if the 
\family typewriter
Ref
\family default
 is present and in 
\family typewriter
ready
\family default
 status, if it is found then the transaction is queried for its state 
\family typewriter
S
\family default
 and if the transaction has not been aborted then the state of the ATS is
 updated to be 
\family typewriter
S
\family default
, and all transactions are either killed or given the 
\family typewriter
idle
\family default
 status.
 
\family typewriter
aborted
\family default
 is replied if the look up failed or if the 
\family typewriter
doquery
\family default
 request returned 
\family typewriter
error
\family default
.
\end_layout

\begin_layout Standard
If the 
\family typewriter
get_pid
\family default
 request is received then the ATS replies with all process ids found in
 its pool and includes its own.
\end_layout

\begin_layout Subparagraph
Transaction
\end_layout

\begin_layout Standard
A transaction can receive an 
\family typewriter
initialize
\family default
 request along with some 
\family typewriter
InitState
\family default
 value, this forces the transaction to update its entire state data with
 the value of 
\family typewriter
InitState
\family default
.
 The transaction can also receive a 
\family typewriter
stop_at_trans
\family default
 request which forces the transaction to stop, i.e.
 shutdown with the reason 
\family typewriter
normal
\family default
.
 If the transaction receive a 
\family typewriter
doquery
\family default
 request but has the aborted status then it ignores the request and replies
 with 
\family typewriter
aborted
\family default
.
 The case where it does not have the 
\family typewriter
aborted
\family default
 status is described below.
\end_layout

\begin_layout Subparagraph
Both
\end_layout

\begin_layout Standard
Both an ATS and a transaction can receive a 
\family typewriter
{doquery, Fun}
\family default
 request and if so then 
\family typewriter
Fun
\family default
 is computed with the current state and the result is replied back to the
 sender, if the function fails then we catch this and reply with 
\family typewriter
error
\family default
 instead.
 We do not update the state of the ATS or transaction.
\end_layout

\begin_layout Standard
I have added a generic case to make sure that any unexpected request is
 simply just ignored instead of crashing the server.
\end_layout

\begin_layout Paragraph
handle_cast/2
\end_layout

\begin_layout Standard
When ever an asynchronous request is sent to the server then the 
\family typewriter
handle_cast/2
\family default
 callback is called by the OTP.
\end_layout

\begin_layout Subparagraph
ATS
\end_layout

\begin_layout Standard
When an ATS received the request 
\family typewriter
{update_t, {Ref, Fun}}
\family default
 it will try to look up the given 
\family typewriter
Ref
\family default
 in its pool of transactions if it exists and is 
\family typewriter
ready
\family default
, meaning that it has not been aborted before and do exist, then the ATS
 sends an asynchronous update request to the transaction with the given
 function 
\family typewriter
Fun
\family default
.
 The state and pool of the ATS is not altered in any way.
\end_layout

\begin_layout Subparagraph
Transaction
\end_layout

\begin_layout Standard
If an aborted transaction receives an update request 
\family typewriter
{update, Fun}
\family default
 then the request is just ignored.
 If it is in the 
\family typewriter
ready
\family default
 status then it tries to perform the update and if the function 
\family typewriter
Fun
\family default
 fails then its state is not updated but its status is set to 
\family typewriter
aborted
\family default
.
 If the function succeeds then the state is updated to be the result of
 the function and the status remains unchanged.
\end_layout

\begin_layout Subparagraph
Both
\end_layout

\begin_layout Standard
Also here is a generic case added to make sure that any unexpected request
 is simply just ignored instead of crashing the server.
\end_layout

\begin_layout Paragraph
handle_info(Info, State)
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
http://www.erlang.org/doc/man/gen_server.html#Module:handle_info-2
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
terminate(Reason, State)
\end_layout

\begin_layout Standard

\family typewriter
terminate/2
\family default
 is called by the 
\emph on
gen_server
\emph default
 right before the process is killed allowing you to do some clean up before
 shutdown.
 As already mentioned I have decided to do this in 
\family typewriter
handle_call/3
\family default
.
 Although if the ATS is terminated for some unexpected reason then I must
 try to stop any ongoing transactions incase it is the ATS that is being
 terminated.
 I the reason is 
\family typewriter
normal
\family default
 then I assume that everything is under control.
\end_layout

\begin_layout Paragraph
code_change(OldVsn, State, Extra)
\end_layout

\begin_layout Standard
The function 
\family typewriter
code_change/3
\family default
 is not used nor implemented to any extend beyond some mere default state
 as the 
\emph on
gen_server
\emph default
 behavior expects this callback function to be implemented.
\end_layout

\begin_layout Subsubsection
Helper functions
\end_layout

\begin_layout Paragraph
ensureLoop(AT, Fun)
\end_layout

\begin_layout Standard
Takes a pid of an ATS and a function 
\family typewriter
Fun
\family default
.
 It begins a transaction, updates it with 
\family typewriter
Fun
\family default
 and tries to commit.
 If the commit succeeds then it returns 
\family typewriter
ok
\family default
, if not then it will try again.
 The function assumes that 
\family typewriter
Fun
\family default
 never fails, and will only stop looping when a commit was successful.
\end_layout

\begin_layout Paragraph
choiceLoop(AT, AllTrans)
\end_layout

\begin_layout Standard

\family typewriter
choiceLoop/2
\family default
 takes an ATS and a list of tuples 
\family typewriter
AllTrans
\family default
 where it assumes that the first element each tuple is of type 
\family typewriter
{ok,Ref}
\family default
 where 
\family typewriter
Ref
\family default
 is some transaction reference.
 If 
\family typewriter
AllTrans
\family default
 is empty then 
\family typewriter
error
\family default
 is returned, otherwise it will listen for the messages 
\family typewriter
{R,done}
\family default
, 
\family typewriter
{R,error}
\family default
 and 
\family typewriter
E
\family default
, where the first message indicates that 
\family typewriter
R
\family default
 is done with its update function and must be committed, and the return
 value of this commit is returned to the caller.
 If the error message is received then the reference is removed from 
\family typewriter
AllTrans
\family default
 and the loop is called once again.
 If some unexpected message 
\family typewriter
E
\family default
 is received then this is discarded and the loop function is called recursively.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
It is assumed that the first instance of 
\family typewriter
{R,done}
\family default
 is also the first to update its state, even though this cannot be completely
 guaranteed due to the process communication.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Appendix A Tests
\end_layout

\begin_layout Subsection
Question 1 Testing
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
When do I consider my implementation to be correct/ working as intended?
 Write it somewhere.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Testing of the parser implemented in the file 
\emph on
SalsaParser.hs
\emph default
 is done through the module 
\family typewriter
Test_Parser
\family default
 implemented in the file 
\emph on
Test_Parser.hs
\emph default
.
 I decided to only test my implementation through the interface of the 
\family typewriter
SalsaParser
\family default
 module.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Why ? And why not also the individual parser.
 -> They are very simple..
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Test_Parser.hs
\end_layout

\begin_layout Standard
This test file implements the module 
\family typewriter
Test_Parser
\family default
 which exports the function 
\family typewriter
runAllTests
\family default
 which, as its name implies, runs all the implemented tests.
 This test file uses both QuickCheck and HUnit.
\begin_inset Note Note
status open

\begin_layout Plain Layout
Move to somewhere else ? In introduction?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The test file is divided into three parts; a QuickCheck part, testing the
 parser with a valid input string, a HUnit part testing parsing of invalid
 input strings and that the correct precedence and associativity is maintained
 and a the third part testing that the parsing of files works as intended.
\end_layout

\begin_layout Paragraph
Part 1
\end_layout

\begin_layout Standard
The QuickCheck part defines a set of lists containing definitions of the
 different components of the Salsa grammar, not to be confused with the
 Salsa definitions described in the grammar.
 These are used when picking a random element to generate, when generating
 the different components.
 The generated test cases tend to get rather big and slow down the test
 I have therefore added a few more cases of 
\begin_inset Quotes eld
\end_inset

move
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

const
\begin_inset Quotes erd
\end_inset

 respectively to the lists commands and exprList to easily add a greater
 chance that the generated data won't grow to large.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Bla bla, describing the newtype TestProgram and the property prop_p_Program..
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Limit the code explanation and focus more on the what the test tests for
 and the assessment that raises from it?
\end_layout

\begin_layout Plain Layout
Evt.
 move the code explanation into the file itself and refer to it.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
As already mentioned then the test checks for that any
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Of course not all possible input values but a random subset of the possible
 input each time the test is run.
\end_layout

\end_inset

 valid input string is parsed to the correct abstract syntax tree.
 When generator a test case then nothing is predefined, all values are random
 generated by QuickCheck Gen monad so everything is tested, although each
 value is restricted to be a valid value, and every command and expr is
 within parenthesis meaning that this test does not test for precedence
 or associativity of the operators.
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Use verbose and comment on the generated data, is it good enough?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Conclusion:
\end_layout

\end_inset


\end_layout

\begin_layout Standard
So far the tests keeps succeeding every time I run it.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
So what then?
\end_layout

\end_inset

 I assume that it works for any valid input string, this means for vidents,
 sidents, white spaces but not precedence and associativity.
\end_layout

\begin_layout Paragraph
Part 2
\end_layout

\begin_layout Standard
This part defines a lot of HUnit tests.
 These are divided into two categories: eleven precedence cases and forty-one
 error cases.
\end_layout

\begin_layout Standard
As these are unit tests I will only test a small subset of input area in
 the individual tests, but based on these tests I assume that it also works
 for the whole area
\begin_inset Note Note
status open

\begin_layout Plain Layout
rephrase?
\end_layout

\end_inset

.
\end_layout

\begin_layout Subparagraph
Precedence
\end_layout

\begin_layout Standard
The first five precedence test cases shows that the operators '@', '||','+'
 and '-' are all left associative.
\end_layout

\begin_layout Standard
The next two show that '@' has higher precedence than '||'.
\end_layout

\begin_layout Standard
Test eight and nine show that '+' and '-' has the same precedence and therefore
 it is the order that matters, even though the end result will be the same
 as + and - in themselves are commutative.
\end_layout

\begin_layout Standard
The last two shows that '.' has higher precedence than both '+' and '-'.
\end_layout

\begin_layout Subparagraph
Error
\end_layout

\begin_layout Standard
The first test shows that an empty string cannot be parsed to anything and
 is therefore not a valid input string.
\end_layout

\begin_layout Standard
The next five tests that a sident cannot be used where a vident is expected.
\end_layout

\begin_layout Standard
Test case seven to eleven shows that a vident cannot be used in place of
 a sident.
\end_layout

\begin_layout Standard
The next four tests shows some of the invalid characters that cannot be
 used in a Salsa program.
\end_layout

\begin_layout Standard
The next two test cases tests that numbers cannot be used as vidents or
 sidents.
\end_layout

\begin_layout Standard
The following two tests shows that letters cannot be used in place of numbers.
\end_layout

\begin_layout Standard
Test case twenty to twenty-two show that not any parenthesis or brackets
 can be used when surrounding a command, group or point.
\end_layout

\begin_layout Standard
The next three test cases shows some of the unsupported operators that does
 not work for the Salsa language.
\end_layout

\begin_layout Standard
The next four tests shows that a reserved word nor a colour can be used
 in place of a sident.
\end_layout

\begin_layout Standard
The thirtieth test case shows that a colour must be one of the specified
 colour names.
\end_layout

\begin_layout Standard
Test next four test cases shows that with lacking white spaces you either
 get an error or an unexpected program.
\end_layout

\begin_layout Standard
Test number 35 shows that when defining a group the given list must be non-empty.
\end_layout

\begin_layout Standard
Test case number 36 to 38 show that the Salsa language is case-sensitive.
\end_layout

\begin_layout Standard
The next two test cases show that negative integers are not supported by
 the grammar.
\end_layout

\begin_layout Standard
The last test show that the above restriction can be bypassed by simply
 creating a expression that subtracts a number from a smaller number, which
 would produce a negative integer when executed.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

All these tests return the expected result and I therefore assume that precedenc
e and associativity works as intended and adheres to the grammar, furthermore
 that the parser returns expected error with a given invalid input string.
\end_layout

\begin_layout Paragraph
Part 3
\end_layout

\begin_layout Standard
This third part contains a set of five unit tests for testing the 
\family typewriter
parseFile
\family default
 function and that it works as intended, it works as intended when parsing
 the content of the file with 
\family typewriter
parseString
\family default
 yields the same result as parsing the file with 
\family typewriter
parseFile
\family default
.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
The first test shows that an empty file is parsed as expected.
\end_layout

\begin_layout Standard
The second and the third test shows that valid Salsa files are also parsed
 as expected.
\end_layout

\begin_layout Standard
The fourth test shows that a invalid Salsa file is parsed as expected.
\end_layout

\begin_layout Standard
The fifth test case show that when parsing a file that does not exist then
 it returns the expected IO exception.
 Note that if the file do exist for some reason then this test will acts
 as a test on the content instead.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Based on these few simple tests that returned the expected values, I assume
 that function 
\family typewriter
parseFile
\family default
 works as intended.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Furthermore based on the tests described above and that they all return
 the expected results, I assume that my grammar and my implementation of
 the 
\family typewriter
SalsaParser
\family default
 module works as intended.
\end_layout

\begin_layout Subsection
Question 2 Testing
\end_layout

\begin_layout Subsection
Question 3 Testing
\end_layout

\begin_layout Standard
-Introduction
\end_layout

\begin_layout Standard
- I decided to let each test section to focus on a single interface/API
 function at a time, and use this separation when describing them here.
\end_layout

\begin_layout Subsubsection
test_at_server.erl
\end_layout

\begin_layout Paragraph
testStart()
\end_layout

\begin_layout Standard
- What does it test
\end_layout

\begin_layout Standard
- How does it test it
\end_layout

\begin_layout Standard
- Does it return the expected result?
\end_layout

\begin_layout Standard
- Are there some things left to be tested?
\end_layout

\begin_layout Paragraph
testBegin()
\end_layout

\begin_layout Paragraph
testStop()
\end_layout

\begin_layout Paragraph
testDoquery()
\end_layout

\begin_layout Paragraph
testQuery_t()
\end_layout

\begin_layout Paragraph
testUpdate_t()
\end_layout

\begin_layout Paragraph
testCommit_t()
\end_layout

\begin_layout Paragraph
testAbort()
\end_layout

\begin_layout Paragraph
testTryUpdate()
\end_layout

\begin_layout Paragraph
testEnsureUpdate()
\end_layout

\begin_layout Paragraph
testChoiceUpdate()
\end_layout

\begin_layout Paragraph
- Overall conclusion
\end_layout

\begin_layout Section
Appendix B Code
\end_layout

\end_body
\end_document
